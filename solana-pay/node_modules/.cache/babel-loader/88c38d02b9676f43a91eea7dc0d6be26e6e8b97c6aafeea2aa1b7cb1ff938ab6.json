{"ast":null,"code":"import { Transaction } from '@solana/web3.js';\nimport fetch from 'cross-fetch';\nimport { toUint8Array } from 'js-base64';\nimport nacl from 'tweetnacl';\n/**\n * Thrown when a transaction response can't be fetched.\n */\nexport class FetchTransactionError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'FetchTransactionError';\n  }\n}\n/**\n * Fetch a transaction from a Solana Pay transaction request link.\n *\n * @param connection - A connection to the cluster.\n * @param account - Account that may sign the transaction.\n * @param link - `link` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#link).\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {FetchTransactionError}\n */\nexport async function fetchTransaction(connection, account, link, {\n  commitment\n} = {}) {\n  const response = await fetch(String(link), {\n    method: 'POST',\n    mode: 'cors',\n    cache: 'no-cache',\n    credentials: 'omit',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      account\n    })\n  });\n  const json = await response.json();\n  if (!json?.transaction) throw new FetchTransactionError('missing transaction');\n  if (typeof json.transaction !== 'string') throw new FetchTransactionError('invalid transaction');\n  const transaction = Transaction.from(toUint8Array(json.transaction));\n  const {\n    signatures,\n    feePayer,\n    recentBlockhash\n  } = transaction;\n  if (signatures.length) {\n    if (!feePayer) throw new FetchTransactionError('missing fee payer');\n    if (!feePayer.equals(signatures[0].publicKey)) throw new FetchTransactionError('invalid fee payer');\n    if (!recentBlockhash) throw new FetchTransactionError('missing recent blockhash');\n    // A valid signature for everything except `account` must be provided.\n    const message = transaction.serializeMessage();\n    for (const {\n      signature,\n      publicKey\n    } of signatures) {\n      if (signature) {\n        if (!nacl.sign.detached.verify(message, signature, publicKey.toBuffer())) throw new FetchTransactionError('invalid signature');\n      } else if (publicKey.equals(account)) {\n        // If the only signature expected is for `account`, ignore the recent blockhash in the transaction.\n        if (signatures.length === 1) {\n          transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n        }\n      } else {\n        throw new FetchTransactionError('missing signature');\n      }\n    }\n  } else {\n    // Ignore the fee payer and recent blockhash in the transaction and initialize them.\n    transaction.feePayer = account;\n    transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n  }\n  return transaction;\n}","map":{"version":3,"names":["Transaction","fetch","toUint8Array","nacl","FetchTransactionError","Error","constructor","name","fetchTransaction","connection","account","link","commitment","response","String","method","mode","cache","credentials","headers","Accept","body","JSON","stringify","json","transaction","from","signatures","feePayer","recentBlockhash","length","equals","publicKey","message","serializeMessage","signature","sign","detached","verify","toBuffer","getRecentBlockhash","blockhash"],"sources":["/home/rochisha/solana-pay/node_modules/@solana/pay/src/fetchTransaction.ts"],"sourcesContent":["import type { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { Transaction } from '@solana/web3.js';\nimport fetch from 'cross-fetch';\nimport { toUint8Array } from 'js-base64';\nimport nacl from 'tweetnacl';\n\n/**\n * Thrown when a transaction response can't be fetched.\n */\nexport class FetchTransactionError extends Error {\n    name = 'FetchTransactionError';\n}\n\n/**\n * Fetch a transaction from a Solana Pay transaction request link.\n *\n * @param connection - A connection to the cluster.\n * @param account - Account that may sign the transaction.\n * @param link - `link` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#link).\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {FetchTransactionError}\n */\nexport async function fetchTransaction(\n    connection: Connection,\n    account: PublicKey,\n    link: string | URL,\n    { commitment }: { commitment?: Commitment } = {}\n): Promise<Transaction> {\n    const response = await fetch(String(link), {\n        method: 'POST',\n        mode: 'cors',\n        cache: 'no-cache',\n        credentials: 'omit',\n        headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ account }),\n    });\n\n    const json = await response.json();\n    if (!json?.transaction) throw new FetchTransactionError('missing transaction');\n    if (typeof json.transaction !== 'string') throw new FetchTransactionError('invalid transaction');\n\n    const transaction = Transaction.from(toUint8Array(json.transaction));\n    const { signatures, feePayer, recentBlockhash } = transaction;\n\n    if (signatures.length) {\n        if (!feePayer) throw new FetchTransactionError('missing fee payer');\n        if (!feePayer.equals(signatures[0].publicKey)) throw new FetchTransactionError('invalid fee payer');\n        if (!recentBlockhash) throw new FetchTransactionError('missing recent blockhash');\n\n        // A valid signature for everything except `account` must be provided.\n        const message = transaction.serializeMessage();\n        for (const { signature, publicKey } of signatures) {\n            if (signature) {\n                if (!nacl.sign.detached.verify(message, signature, publicKey.toBuffer()))\n                    throw new FetchTransactionError('invalid signature');\n            } else if (publicKey.equals(account)) {\n                // If the only signature expected is for `account`, ignore the recent blockhash in the transaction.\n                if (signatures.length === 1) {\n                    transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n                }\n            } else {\n                throw new FetchTransactionError('missing signature');\n            }\n        }\n    } else {\n        // Ignore the fee payer and recent blockhash in the transaction and initialize them.\n        transaction.feePayer = account;\n        transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n    }\n\n    return transaction;\n}\n"],"mappings":"AACA,SAASA,WAAW,QAAQ,iBAAiB;AAC7C,OAAOC,KAAK,MAAM,aAAa;AAC/B,SAASC,YAAY,QAAQ,WAAW;AACxC,OAAOC,IAAI,MAAM,WAAW;AAE5B;;;AAGA,OAAM,MAAOC,qBAAsB,SAAQC,KAAK;EAAhDC,YAAA;;IACI,KAAAC,IAAI,GAAG,uBAAuB;EAClC;;AAEA;;;;;;;;;;AAUA,OAAO,eAAeC,gBAAgBA,CAClCC,UAAsB,EACtBC,OAAkB,EAClBC,IAAkB,EAClB;EAAEC;AAAU,IAAkC,EAAE;EAEhD,MAAMC,QAAQ,GAAG,MAAMZ,KAAK,CAACa,MAAM,CAACH,IAAI,CAAC,EAAE;IACvCI,MAAM,EAAE,MAAM;IACdC,IAAI,EAAE,MAAM;IACZC,KAAK,EAAE,UAAU;IACjBC,WAAW,EAAE,MAAM;IACnBC,OAAO,EAAE;MACLC,MAAM,EAAE,kBAAkB;MAC1B,cAAc,EAAE;KACnB;IACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;MAAEb;IAAO,CAAE;GACnC,CAAC;EAEF,MAAMc,IAAI,GAAG,MAAMX,QAAQ,CAACW,IAAI,EAAE;EAClC,IAAI,CAACA,IAAI,EAAEC,WAAW,EAAE,MAAM,IAAIrB,qBAAqB,CAAC,qBAAqB,CAAC;EAC9E,IAAI,OAAOoB,IAAI,CAACC,WAAW,KAAK,QAAQ,EAAE,MAAM,IAAIrB,qBAAqB,CAAC,qBAAqB,CAAC;EAEhG,MAAMqB,WAAW,GAAGzB,WAAW,CAAC0B,IAAI,CAACxB,YAAY,CAACsB,IAAI,CAACC,WAAW,CAAC,CAAC;EACpE,MAAM;IAAEE,UAAU;IAAEC,QAAQ;IAAEC;EAAe,CAAE,GAAGJ,WAAW;EAE7D,IAAIE,UAAU,CAACG,MAAM,EAAE;IACnB,IAAI,CAACF,QAAQ,EAAE,MAAM,IAAIxB,qBAAqB,CAAC,mBAAmB,CAAC;IACnE,IAAI,CAACwB,QAAQ,CAACG,MAAM,CAACJ,UAAU,CAAC,CAAC,CAAC,CAACK,SAAS,CAAC,EAAE,MAAM,IAAI5B,qBAAqB,CAAC,mBAAmB,CAAC;IACnG,IAAI,CAACyB,eAAe,EAAE,MAAM,IAAIzB,qBAAqB,CAAC,0BAA0B,CAAC;IAEjF;IACA,MAAM6B,OAAO,GAAGR,WAAW,CAACS,gBAAgB,EAAE;IAC9C,KAAK,MAAM;MAAEC,SAAS;MAAEH;IAAS,CAAE,IAAIL,UAAU,EAAE;MAC/C,IAAIQ,SAAS,EAAE;QACX,IAAI,CAAChC,IAAI,CAACiC,IAAI,CAACC,QAAQ,CAACC,MAAM,CAACL,OAAO,EAAEE,SAAS,EAAEH,SAAS,CAACO,QAAQ,EAAE,CAAC,EACpE,MAAM,IAAInC,qBAAqB,CAAC,mBAAmB,CAAC;OAC3D,MAAM,IAAI4B,SAAS,CAACD,MAAM,CAACrB,OAAO,CAAC,EAAE;QAClC;QACA,IAAIiB,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE;UACzBL,WAAW,CAACI,eAAe,GAAG,CAAC,MAAMpB,UAAU,CAAC+B,kBAAkB,CAAC5B,UAAU,CAAC,EAAE6B,SAAS;;OAEhG,MAAM;QACH,MAAM,IAAIrC,qBAAqB,CAAC,mBAAmB,CAAC;;;GAG/D,MAAM;IACH;IACAqB,WAAW,CAACG,QAAQ,GAAGlB,OAAO;IAC9Be,WAAW,CAACI,eAAe,GAAG,CAAC,MAAMpB,UAAU,CAAC+B,kBAAkB,CAAC5B,UAAU,CAAC,EAAE6B,SAAS;;EAG7F,OAAOhB,WAAW;AACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
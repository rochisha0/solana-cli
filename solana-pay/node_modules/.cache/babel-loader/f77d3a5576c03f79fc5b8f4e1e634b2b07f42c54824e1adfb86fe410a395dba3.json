{"ast":null,"code":"import { struct, u8 } from '@solana/buffer-layout';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\nexport var TransferHookInstruction;\n(function (TransferHookInstruction) {\n  TransferHookInstruction[TransferHookInstruction[\"Initialize\"] = 0] = \"Initialize\";\n  TransferHookInstruction[TransferHookInstruction[\"Update\"] = 1] = \"Update\";\n})(TransferHookInstruction || (TransferHookInstruction = {}));\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct([u8('instruction'), u8('transferHookInstruction'), publicKey('authority'), publicKey('transferHookProgramId')]);\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(mint, authority, transferHookProgramId, programId) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = [{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }];\n  const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n  initializeTransferHookInstructionData.encode({\n    instruction: TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Initialize,\n    authority,\n    transferHookProgramId\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct([u8('instruction'), u8('transferHookInstruction'), publicKey('transferHookProgramId')]);\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(mint, authority, transferHookProgramId, multiSigners = [], programId = TOKEN_2022_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const keys = addSigners([{\n    pubkey: mint,\n    isSigner: false,\n    isWritable: true\n  }], authority, multiSigners);\n  const data = Buffer.alloc(updateTransferHookInstructionData.span);\n  updateTransferHookInstructionData.encode({\n    instruction: TokenInstruction.TransferHookExtension,\n    transferHookInstruction: TransferHookInstruction.Update,\n    transferHookProgramId\n  }, data);\n  return new TransactionInstruction({\n    keys,\n    programId,\n    data\n  });\n}\nfunction deEscalateAccountMeta(accountMeta, accountMetas) {\n  const maybeHighestPrivileges = accountMetas.filter(x => x.pubkey === accountMeta.pubkey).reduce((acc, x) => {\n    if (!acc) return {\n      isSigner: x.isSigner,\n      isWritable: x.isWritable\n    };\n    return {\n      isSigner: acc.isSigner || x.isSigner,\n      isWritable: acc.isWritable || x.isWritable\n    };\n  }, undefined);\n  if (maybeHighestPrivileges) {\n    const {\n      isSigner,\n      isWritable\n    } = maybeHighestPrivileges;\n    if (!isSigner && isSigner !== accountMeta.isSigner) {\n      accountMeta.isSigner = false;\n    }\n    if (!isWritable && isWritable !== accountMeta.isWritable) {\n      accountMeta.isWritable = false;\n    }\n  }\n  return accountMeta;\n}\n/**\n * Add extra accounts needed for transfer hook to an instruction\n *\n * @param connection      Connection to use\n * @param instruction     The transferChecked instruction to add accounts to\n * @param commitment      Commitment to use\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function addExtraAccountsToInstruction(connection, instruction, mint, commitment, programId = TOKEN_PROGRAM_ID) {\n  if (!programSupportsExtensions(programId)) {\n    throw new TokenUnsupportedInstructionError();\n  }\n  const mintInfo = await getMint(connection, mint, commitment, programId);\n  const transferHook = getTransferHook(mintInfo);\n  if (transferHook == null) {\n    return instruction;\n  }\n  const extraAccountsAccount = getExtraAccountMetaAddress(mint, transferHook.programId);\n  const extraAccountsInfo = await connection.getAccountInfo(extraAccountsAccount, commitment);\n  if (extraAccountsInfo == null) {\n    return instruction;\n  }\n  const extraAccountMetas = getExtraAccountMetas(extraAccountsInfo);\n  const accountMetas = instruction.keys;\n  for (const extraAccountMeta of extraAccountMetas) {\n    const accountMetaUnchecked = await resolveExtraAccountMeta(connection, extraAccountMeta, accountMetas, instruction.data, transferHook.programId);\n    const accountMeta = deEscalateAccountMeta(accountMetaUnchecked, accountMetas);\n    accountMetas.push(accountMeta);\n  }\n  accountMetas.push({\n    pubkey: transferHook.programId,\n    isSigner: false,\n    isWritable: false\n  });\n  accountMetas.push({\n    pubkey: extraAccountsAccount,\n    isSigner: false,\n    isWritable: false\n  });\n  return new TransactionInstruction({\n    keys: accountMetas,\n    programId,\n    data: instruction.data\n  });\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {\n  const rawInstruction = createTransferCheckedInstruction(source, mint, destination, authority, amount, decimals, multiSigners, programId);\n  const hydratedInstruction = await addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);\n  return hydratedInstruction;\n}\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(connection, source, mint, destination, authority, amount, decimals, fee, multiSigners = [], commitment, programId = TOKEN_PROGRAM_ID) {\n  const rawInstruction = createTransferCheckedWithFeeInstruction(source, mint, destination, authority, amount, decimals, fee, multiSigners, programId);\n  const hydratedInstruction = await addExtraAccountsToInstruction(connection, rawInstruction, mint, commitment, programId);\n  return hydratedInstruction;\n}","map":{"version":3,"names":["struct","u8","TransactionInstruction","programSupportsExtensions","TOKEN_2022_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenUnsupportedInstructionError","addSigners","TokenInstruction","publicKey","createTransferCheckedInstruction","createTransferCheckedWithFeeInstruction","getMint","getExtraAccountMetaAddress","getExtraAccountMetas","getTransferHook","resolveExtraAccountMeta","TransferHookInstruction","initializeTransferHookInstructionData","createInitializeTransferHookInstruction","mint","authority","transferHookProgramId","programId","keys","pubkey","isSigner","isWritable","data","Buffer","alloc","span","encode","instruction","TransferHookExtension","transferHookInstruction","Initialize","updateTransferHookInstructionData","createUpdateTransferHookInstruction","multiSigners","Update","deEscalateAccountMeta","accountMeta","accountMetas","maybeHighestPrivileges","filter","x","reduce","acc","undefined","addExtraAccountsToInstruction","connection","commitment","mintInfo","transferHook","extraAccountsAccount","extraAccountsInfo","getAccountInfo","extraAccountMetas","extraAccountMeta","accountMetaUnchecked","push","createTransferCheckedWithTransferHookInstruction","source","destination","amount","decimals","rawInstruction","hydratedInstruction","createTransferCheckedWithFeeAndTransferHookInstruction","fee"],"sources":["/home/rochisha/solana-pay/node_modules/@solana/spl-token/src/extensions/transferHook/instructions.ts"],"sourcesContent":["import { struct, u8 } from '@solana/buffer-layout';\nimport type { AccountMeta, Commitment, Connection, PublicKey, Signer } from '@solana/web3.js';\nimport { TransactionInstruction } from '@solana/web3.js';\nimport { programSupportsExtensions, TOKEN_2022_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../../constants.js';\nimport { TokenUnsupportedInstructionError } from '../../errors.js';\nimport { addSigners } from '../../instructions/internal.js';\nimport { TokenInstruction } from '../../instructions/types.js';\nimport { publicKey } from '@solana/buffer-layout-utils';\nimport { createTransferCheckedInstruction } from '../../instructions/transferChecked.js';\nimport { createTransferCheckedWithFeeInstruction } from '../transferFee/instructions.js';\nimport { getMint } from '../../state/mint.js';\nimport { getExtraAccountMetaAddress, getExtraAccountMetas, getTransferHook, resolveExtraAccountMeta } from './state.js';\n\nexport enum TransferHookInstruction {\n    Initialize = 0,\n    Update = 1,\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface InitializeTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Initialize;\n    authority: PublicKey;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const initializeTransferHookInstructionData = struct<InitializeTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('authority'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an InitializeTransferHook instruction\n *\n * @param mint                  Token mint account\n * @param authority             Transfer hook authority account\n * @param transferHookProgramId Transfer hook program account\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createInitializeTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    programId: PublicKey\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n    const keys = [{ pubkey: mint, isSigner: false, isWritable: true }];\n\n    const data = Buffer.alloc(initializeTransferHookInstructionData.span);\n    initializeTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Initialize,\n            authority,\n            transferHookProgramId,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\n/** Deserialized instruction for the initiation of an transfer hook */\nexport interface UpdateTransferHookInstructionData {\n    instruction: TokenInstruction.TransferHookExtension;\n    transferHookInstruction: TransferHookInstruction.Update;\n    transferHookProgramId: PublicKey;\n}\n\n/** The struct that represents the instruction data as it is read by the program */\nexport const updateTransferHookInstructionData = struct<UpdateTransferHookInstructionData>([\n    u8('instruction'),\n    u8('transferHookInstruction'),\n    publicKey('transferHookProgramId'),\n]);\n\n/**\n * Construct an UpdateTransferHook instruction\n *\n * @param mint                  Mint to update\n * @param authority             The mint's transfer hook authority\n * @param transferHookProgramId The new transfer hook program account\n * @param signers               The signer account(s) for a multisig\n * @param tokenProgramId        SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport function createUpdateTransferHookInstruction(\n    mint: PublicKey,\n    authority: PublicKey,\n    transferHookProgramId: PublicKey,\n    multiSigners: (Signer | PublicKey)[] = [],\n    programId = TOKEN_2022_PROGRAM_ID\n): TransactionInstruction {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const keys = addSigners([{ pubkey: mint, isSigner: false, isWritable: true }], authority, multiSigners);\n    const data = Buffer.alloc(updateTransferHookInstructionData.span);\n    updateTransferHookInstructionData.encode(\n        {\n            instruction: TokenInstruction.TransferHookExtension,\n            transferHookInstruction: TransferHookInstruction.Update,\n            transferHookProgramId,\n        },\n        data\n    );\n\n    return new TransactionInstruction({ keys, programId, data });\n}\n\nfunction deEscalateAccountMeta(accountMeta: AccountMeta, accountMetas: AccountMeta[]): AccountMeta {\n    const maybeHighestPrivileges = accountMetas\n        .filter((x) => x.pubkey === accountMeta.pubkey)\n        .reduce<{ isSigner: boolean; isWritable: boolean } | undefined>((acc, x) => {\n            if (!acc) return { isSigner: x.isSigner, isWritable: x.isWritable };\n            return { isSigner: acc.isSigner || x.isSigner, isWritable: acc.isWritable || x.isWritable };\n        }, undefined);\n    if (maybeHighestPrivileges) {\n        const { isSigner, isWritable } = maybeHighestPrivileges;\n        if (!isSigner && isSigner !== accountMeta.isSigner) {\n            accountMeta.isSigner = false;\n        }\n        if (!isWritable && isWritable !== accountMeta.isWritable) {\n            accountMeta.isWritable = false;\n        }\n    }\n    return accountMeta;\n}\n\n/**\n * Add extra accounts needed for transfer hook to an instruction\n *\n * @param connection      Connection to use\n * @param instruction     The transferChecked instruction to add accounts to\n * @param commitment      Commitment to use\n * @param programId       SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function addExtraAccountsToInstruction(\n    connection: Connection,\n    instruction: TransactionInstruction,\n    mint: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<TransactionInstruction> {\n    if (!programSupportsExtensions(programId)) {\n        throw new TokenUnsupportedInstructionError();\n    }\n\n    const mintInfo = await getMint(connection, mint, commitment, programId);\n    const transferHook = getTransferHook(mintInfo);\n    if (transferHook == null) {\n        return instruction;\n    }\n\n    const extraAccountsAccount = getExtraAccountMetaAddress(mint, transferHook.programId);\n    const extraAccountsInfo = await connection.getAccountInfo(extraAccountsAccount, commitment);\n    if (extraAccountsInfo == null) {\n        return instruction;\n    }\n\n    const extraAccountMetas = getExtraAccountMetas(extraAccountsInfo);\n\n    const accountMetas = instruction.keys;\n\n    for (const extraAccountMeta of extraAccountMetas) {\n        const accountMetaUnchecked = await resolveExtraAccountMeta(\n            connection,\n            extraAccountMeta,\n            accountMetas,\n            instruction.data,\n            transferHook.programId\n        );\n        const accountMeta = deEscalateAccountMeta(accountMetaUnchecked, accountMetas);\n        accountMetas.push(accountMeta);\n    }\n    accountMetas.push({ pubkey: transferHook.programId, isSigner: false, isWritable: false });\n    accountMetas.push({ pubkey: extraAccountsAccount, isSigner: false, isWritable: false });\n\n    return new TransactionInstruction({ keys: accountMetas, programId, data: instruction.data });\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n) {\n    const rawInstruction = createTransferCheckedInstruction(\n        source,\n        mint,\n        destination,\n        authority,\n        amount,\n        decimals,\n        multiSigners,\n        programId\n    );\n\n    const hydratedInstruction = await addExtraAccountsToInstruction(\n        connection,\n        rawInstruction,\n        mint,\n        commitment,\n        programId\n    );\n\n    return hydratedInstruction;\n}\n\n/**\n * Construct an transferChecked instruction with extra accounts for transfer hook\n *\n * @param connection            Connection to use\n * @param source                Source account\n * @param mint                  Mint to update\n * @param destination           Destination account\n * @param authority             The mint's transfer hook authority\n * @param amount                The amount of tokens to transfer\n * @param decimals              Number of decimals in transfer amount\n * @param fee                   The calculated fee for the transfer fee extension\n * @param multiSigners          The signer account(s) for a multisig\n * @param commitment            Commitment to use\n * @param programId             SPL Token program account\n *\n * @return Instruction to add to a transaction\n */\nexport async function createTransferCheckedWithFeeAndTransferHookInstruction(\n    connection: Connection,\n    source: PublicKey,\n    mint: PublicKey,\n    destination: PublicKey,\n    authority: PublicKey,\n    amount: bigint,\n    decimals: number,\n    fee: bigint,\n    multiSigners: (Signer | PublicKey)[] = [],\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n) {\n    const rawInstruction = createTransferCheckedWithFeeInstruction(\n        source,\n        mint,\n        destination,\n        authority,\n        amount,\n        decimals,\n        fee,\n        multiSigners,\n        programId\n    );\n\n    const hydratedInstruction = await addExtraAccountsToInstruction(\n        connection,\n        rawInstruction,\n        mint,\n        commitment,\n        programId\n    );\n\n    return hydratedInstruction;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
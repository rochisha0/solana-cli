{"ast":null,"code":"import { TlvInvalidAccountDataError } from './errors.js';\nexport class TlvState {\n  constructor(buffer, discriminatorSize = 2, lengthSize = 2, offset = 0) {\n    this.tlvData = buffer.subarray(offset);\n    this.discriminatorSize = discriminatorSize;\n    this.lengthSize = lengthSize;\n  }\n  /**\n   * Get the raw tlv data\n   *\n   * @return the raw tlv data\n   */\n  get data() {\n    return this.tlvData;\n  }\n  readEntryLength(size, offset, constructor) {\n    switch (size) {\n      case 1:\n        return constructor(this.tlvData.readUInt8(offset));\n      case 2:\n        return constructor(this.tlvData.readUInt16LE(offset));\n      case 4:\n        return constructor(this.tlvData.readUInt32LE(offset));\n      case 8:\n        return constructor(this.tlvData.readBigUInt64LE(offset));\n    }\n  }\n  /**\n   * Get a single entry from the tlv data. This function returns the first entry with the given type.\n   *\n   * @param type the type of the entry to get\n   *\n   * @return the entry from the tlv data or null\n   */\n  firstBytes(discriminator) {\n    const entries = this.bytesRepeating(discriminator, 1);\n    return entries.length > 0 ? entries[0] : null;\n  }\n  /**\n   * Get a multiple entries from the tlv data. This function returns `count` or less entries with the given type.\n   *\n   * @param type the type of the entry to get\n   * @param count the number of entries to get (0 for all entries)\n   *\n   * @return the entry from the tlv data or null\n   */\n  bytesRepeating(discriminator, count = 0) {\n    const entries = [];\n    let offset = 0;\n    while (offset < this.tlvData.length) {\n      if (offset + this.discriminatorSize + this.lengthSize > this.tlvData.length) {\n        throw new TlvInvalidAccountDataError();\n      }\n      const type = this.tlvData.subarray(offset, offset + this.discriminatorSize);\n      offset += this.discriminatorSize;\n      const entryLength = this.readEntryLength(this.lengthSize, offset, Number);\n      offset += this.lengthSize;\n      if (offset + entryLength > this.tlvData.length) {\n        throw new TlvInvalidAccountDataError();\n      }\n      if (type.equals(discriminator)) {\n        entries.push(this.tlvData.subarray(offset, offset + entryLength));\n      }\n      if (count > 0 && entries.length >= count) {\n        break;\n      }\n      offset += entryLength;\n    }\n    return entries;\n  }\n  /**\n   * Get all the discriminators from the tlv data. This function will return a type multiple times if it occurs multiple times in the tlv data.\n   *\n   * @return a list of the discriminators.\n   */\n  discriminators() {\n    const discriminators = [];\n    let offset = 0;\n    while (offset < this.tlvData.length) {\n      if (offset + this.discriminatorSize + this.lengthSize > this.tlvData.length) {\n        throw new TlvInvalidAccountDataError();\n      }\n      const type = this.tlvData.subarray(offset, offset + this.discriminatorSize);\n      discriminators.push(type);\n      offset += this.discriminatorSize;\n      const entryLength = this.readEntryLength(this.lengthSize, offset, Number);\n      offset += this.lengthSize;\n      if (offset + entryLength > this.tlvData.length) {\n        throw new TlvInvalidAccountDataError();\n      }\n      offset += entryLength;\n    }\n    return discriminators;\n  }\n}","map":{"version":3,"names":["TlvInvalidAccountDataError","TlvState","constructor","buffer","discriminatorSize","lengthSize","offset","tlvData","subarray","data","readEntryLength","size","readUInt8","readUInt16LE","readUInt32LE","readBigUInt64LE","firstBytes","discriminator","entries","bytesRepeating","length","count","type","entryLength","Number","equals","push","discriminators"],"sources":["/home/rochisha/solana-pay/node_modules/@solana/spl-type-length-value/src/tlvState.ts"],"sourcesContent":["import { TlvInvalidAccountDataError } from './errors.js';\n\nexport type LengthSize = 1 | 2 | 4 | 8;\n\nexport type Discriminator = Uint8Array;\n\nexport class TlvState {\n    private readonly tlvData: Buffer;\n    private readonly discriminatorSize: number;\n    private readonly lengthSize: LengthSize;\n\n    public constructor(buffer: Buffer, discriminatorSize = 2, lengthSize: LengthSize = 2, offset: number = 0) {\n        this.tlvData = buffer.subarray(offset);\n        this.discriminatorSize = discriminatorSize;\n        this.lengthSize = lengthSize;\n    }\n\n    /**\n     * Get the raw tlv data\n     *\n     * @return the raw tlv data\n     */\n    public get data(): Buffer {\n        return this.tlvData;\n    }\n\n    private readEntryLength<T>(size: LengthSize, offset: number, constructor: (x: number | bigint) => T): T {\n        switch (size) {\n            case 1:\n                return constructor(this.tlvData.readUInt8(offset));\n            case 2:\n                return constructor(this.tlvData.readUInt16LE(offset));\n            case 4:\n                return constructor(this.tlvData.readUInt32LE(offset));\n            case 8:\n                return constructor(this.tlvData.readBigUInt64LE(offset));\n        }\n    }\n\n    /**\n     * Get a single entry from the tlv data. This function returns the first entry with the given type.\n     *\n     * @param type the type of the entry to get\n     *\n     * @return the entry from the tlv data or null\n     */\n    public firstBytes(discriminator: Discriminator): Buffer | null {\n        const entries = this.bytesRepeating(discriminator, 1);\n        return entries.length > 0 ? entries[0] : null;\n    }\n\n    /**\n     * Get a multiple entries from the tlv data. This function returns `count` or less entries with the given type.\n     *\n     * @param type the type of the entry to get\n     * @param count the number of entries to get (0 for all entries)\n     *\n     * @return the entry from the tlv data or null\n     */\n    public bytesRepeating(discriminator: Discriminator, count = 0): Buffer[] {\n        const entries: Buffer[] = [];\n        let offset = 0;\n        while (offset < this.tlvData.length) {\n            if (offset + this.discriminatorSize + this.lengthSize > this.tlvData.length) {\n                throw new TlvInvalidAccountDataError();\n            }\n            const type = this.tlvData.subarray(offset, offset + this.discriminatorSize);\n            offset += this.discriminatorSize;\n            const entryLength = this.readEntryLength(this.lengthSize, offset, Number);\n            offset += this.lengthSize;\n            if (offset + entryLength > this.tlvData.length) {\n                throw new TlvInvalidAccountDataError();\n            }\n            if (type.equals(discriminator)) {\n                entries.push(this.tlvData.subarray(offset, offset + entryLength));\n            }\n            if (count > 0 && entries.length >= count) {\n                break;\n            }\n            offset += entryLength;\n        }\n        return entries;\n    }\n\n    /**\n     * Get all the discriminators from the tlv data. This function will return a type multiple times if it occurs multiple times in the tlv data.\n     *\n     * @return a list of the discriminators.\n     */\n    public discriminators(): Buffer[] {\n        const discriminators: Buffer[] = [];\n        let offset = 0;\n        while (offset < this.tlvData.length) {\n            if (offset + this.discriminatorSize + this.lengthSize > this.tlvData.length) {\n                throw new TlvInvalidAccountDataError();\n            }\n            const type = this.tlvData.subarray(offset, offset + this.discriminatorSize);\n            discriminators.push(type);\n            offset += this.discriminatorSize;\n            const entryLength = this.readEntryLength(this.lengthSize, offset, Number);\n            offset += this.lengthSize;\n            if (offset + entryLength > this.tlvData.length) {\n                throw new TlvInvalidAccountDataError();\n            }\n            offset += entryLength;\n        }\n        return discriminators;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
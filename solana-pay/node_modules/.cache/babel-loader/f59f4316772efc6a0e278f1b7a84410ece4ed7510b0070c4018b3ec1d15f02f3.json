{"ast":null,"code":"import { createEncoder, getEncodedSize, createDecoder, combineCodec, assertByteArrayHasEnoughBytesForCodec, assertIsFixedSize, mapEncoder, mapDecoder, fixEncoder, fixDecoder, assertByteArrayIsNotEmptyForCodec, isFixedSize } from '@solana/codecs-core';\nimport { getU32Encoder, getU32Decoder, getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SolanaError, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT, SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT } from '@solana/errors';\n\n// src/array.ts\nfunction assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {\n  if (expected !== actual) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n      actual,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction maxCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : Math.max(all, size), 0);\n}\nfunction sumCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);\n}\nfunction getFixedSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : null;\n}\nfunction getMaxSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n\n// src/array.ts\nfunction getArrayEncoder(item, config = {}) {\n  const size = config.size ?? getU32Encoder();\n  const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize !== null ? {\n      fixedSize\n    } : {\n      getSizeFromValue: array => {\n        const prefixSize = typeof size === \"object\" ? getEncodedSize(array.length, size) : 0;\n        return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n      },\n      maxSize\n    }),\n    write: (array, bytes, offset) => {\n      if (typeof size === \"number\") {\n        assertValidNumberOfItemsForCodec(\"array\", size, array.length);\n      }\n      if (typeof size === \"object\") {\n        offset = size.write(array.length, bytes, offset);\n      }\n      array.forEach(value => {\n        offset = item.write(value, bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getArrayDecoder(item, config = {}) {\n  const size = config.size ?? getU32Decoder();\n  const itemSize = getFixedSize(item);\n  const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize !== null ? {\n      fixedSize\n    } : {\n      maxSize\n    }),\n    read: (bytes, offset) => {\n      const array = [];\n      if (typeof size === \"object\" && bytes.slice(offset).length === 0) {\n        return [array, offset];\n      }\n      if (size === \"remainder\") {\n        while (offset < bytes.length) {\n          const [value, newOffset2] = item.read(bytes, offset);\n          offset = newOffset2;\n          array.push(value);\n        }\n        return [array, offset];\n      }\n      const [resolvedSize, newOffset] = typeof size === \"number\" ? [size, offset] : size.read(bytes, offset);\n      offset = newOffset;\n      for (let i = 0; i < resolvedSize; i += 1) {\n        const [value, newOffset2] = item.read(bytes, offset);\n        offset = newOffset2;\n        array.push(value);\n      }\n      return [array, offset];\n    }\n  });\n}\nfunction getArrayCodec(item, config = {}) {\n  return combineCodec(getArrayEncoder(item, config), getArrayDecoder(item, config));\n}\nfunction computeArrayLikeCodecSize(size, itemSize) {\n  if (typeof size !== \"number\") return null;\n  if (size === 0) return 0;\n  return itemSize === null ? null : itemSize * size;\n}\nfunction getBitArrayEncoder(size, config = {}) {\n  const parsedConfig = typeof config === \"boolean\" ? {\n    backward: config\n  } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createEncoder({\n    fixedSize: size,\n    write(value, bytes, offset) {\n      const bytesToAdd = [];\n      for (let i = 0; i < size; i += 1) {\n        let byte = 0;\n        for (let j = 0; j < 8; j += 1) {\n          const feature = Number(value[i * 8 + j] ?? 0);\n          byte |= feature << (backward ? j : 7 - j);\n        }\n        if (backward) {\n          bytesToAdd.unshift(byte);\n        } else {\n          bytesToAdd.push(byte);\n        }\n      }\n      bytes.set(bytesToAdd, offset);\n      return size;\n    }\n  });\n}\nfunction getBitArrayDecoder(size, config = {}) {\n  const parsedConfig = typeof config === \"boolean\" ? {\n    backward: config\n  } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createDecoder({\n    fixedSize: size,\n    read(bytes, offset) {\n      assertByteArrayHasEnoughBytesForCodec(\"bitArray\", size, bytes, offset);\n      const booleans = [];\n      let slice = bytes.slice(offset, offset + size);\n      slice = backward ? slice.reverse() : slice;\n      slice.forEach(byte => {\n        for (let i = 0; i < 8; i += 1) {\n          if (backward) {\n            booleans.push(Boolean(byte & 1));\n            byte >>= 1;\n          } else {\n            booleans.push(Boolean(byte & 128));\n            byte <<= 1;\n          }\n        }\n      });\n      return [booleans, offset + size];\n    }\n  });\n}\nfunction getBitArrayCodec(size, config = {}) {\n  return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\nfunction getBooleanEncoder(config = {}) {\n  const size = config.size ?? getU8Encoder();\n  assertIsFixedSize(size);\n  return mapEncoder(size, value => value ? 1 : 0);\n}\nfunction getBooleanDecoder(config = {}) {\n  const size = config.size ?? getU8Decoder();\n  assertIsFixedSize(size);\n  return mapDecoder(size, value => Number(value) === 1);\n}\nfunction getBooleanCodec(config = {}) {\n  return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\nfunction getBytesEncoder(config = {}) {\n  const size = config.size ?? \"variable\";\n  const byteEncoder = createEncoder({\n    getSizeFromValue: value => value.length,\n    write: (value, bytes, offset) => {\n      bytes.set(value, offset);\n      return offset + value.length;\n    }\n  });\n  if (size === \"variable\") {\n    return byteEncoder;\n  }\n  if (typeof size === \"number\") {\n    return fixEncoder(byteEncoder, size);\n  }\n  return createEncoder({\n    getSizeFromValue: value => getEncodedSize(value.length, size) + value.length,\n    write: (value, bytes, offset) => {\n      offset = size.write(value.length, bytes, offset);\n      return byteEncoder.write(value, bytes, offset);\n    }\n  });\n}\nfunction getBytesDecoder(config = {}) {\n  const size = config.size ?? \"variable\";\n  const byteDecoder = createDecoder({\n    read: (bytes, offset) => {\n      const slice = bytes.slice(offset);\n      return [slice, offset + slice.length];\n    }\n  });\n  if (size === \"variable\") {\n    return byteDecoder;\n  }\n  if (typeof size === \"number\") {\n    return fixDecoder(byteDecoder, size);\n  }\n  return createDecoder({\n    read: (bytes, offset) => {\n      assertByteArrayIsNotEmptyForCodec(\"bytes\", bytes, offset);\n      const [lengthBigInt, lengthOffset] = size.read(bytes, offset);\n      const length = Number(lengthBigInt);\n      offset = lengthOffset;\n      const contentBytes = bytes.slice(offset, offset + length);\n      assertByteArrayHasEnoughBytesForCodec(\"bytes\", length, contentBytes);\n      const [value, contentOffset] = byteDecoder.read(contentBytes, 0);\n      offset += contentOffset;\n      return [value, offset];\n    }\n  });\n}\nfunction getBytesCodec(config = {}) {\n  return combineCodec(getBytesEncoder(config), getBytesDecoder(config));\n}\nfunction getDataEnumEncoder(variants, config = {}) {\n  const prefix = config.size ?? getU8Encoder();\n  const fixedSize = getDataEnumFixedSize(variants, prefix);\n  return createEncoder({\n    ...(fixedSize !== null ? {\n      fixedSize\n    } : {\n      getSizeFromValue: variant => {\n        const discriminator = getVariantDiscriminator(variants, variant);\n        const variantEncoder = variants[discriminator][1];\n        return getEncodedSize(discriminator, prefix) + getEncodedSize(variant, variantEncoder);\n      },\n      maxSize: getDataEnumMaxSize(variants, prefix)\n    }),\n    write: (variant, bytes, offset) => {\n      const discriminator = getVariantDiscriminator(variants, variant);\n      offset = prefix.write(discriminator, bytes, offset);\n      const variantEncoder = variants[discriminator][1];\n      return variantEncoder.write(variant, bytes, offset);\n    }\n  });\n}\nfunction getDataEnumDecoder(variants, config = {}) {\n  const prefix = config.size ?? getU8Decoder();\n  const fixedSize = getDataEnumFixedSize(variants, prefix);\n  return createDecoder({\n    ...(fixedSize !== null ? {\n      fixedSize\n    } : {\n      maxSize: getDataEnumMaxSize(variants, prefix)\n    }),\n    read: (bytes, offset) => {\n      assertByteArrayIsNotEmptyForCodec(\"dataEnum\", bytes, offset);\n      const [discriminator, dOffset] = prefix.read(bytes, offset);\n      offset = dOffset;\n      const variantField = variants[Number(discriminator)] ?? null;\n      if (!variantField) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n          discriminator,\n          maxRange: variants.length - 1,\n          minRange: 0\n        });\n      }\n      const [variant, vOffset] = variantField[1].read(bytes, offset);\n      offset = vOffset;\n      return [{\n        __kind: variantField[0],\n        ...(variant ?? {})\n      }, offset];\n    }\n  });\n}\nfunction getDataEnumCodec(variants, config = {}) {\n  return combineCodec(getDataEnumEncoder(variants, config), getDataEnumDecoder(variants, config));\n}\nfunction getDataEnumFixedSize(variants, prefix) {\n  if (variants.length === 0) return isFixedSize(prefix) ? prefix.fixedSize : null;\n  if (!isFixedSize(variants[0][1])) return null;\n  const variantSize = variants[0][1].fixedSize;\n  const sameSizedVariants = variants.every(variant => isFixedSize(variant[1]) && variant[1].fixedSize === variantSize);\n  if (!sameSizedVariants) return null;\n  return isFixedSize(prefix) ? prefix.fixedSize + variantSize : null;\n}\nfunction getDataEnumMaxSize(variants, prefix) {\n  const maxVariantSize = maxCodecSizes(variants.map(([, codec]) => getMaxSize(codec)));\n  return sumCodecSizes([getMaxSize(prefix), maxVariantSize]) ?? void 0;\n}\nfunction getVariantDiscriminator(variants, variant) {\n  const discriminator = variants.findIndex(([key]) => variant.__kind === key);\n  if (discriminator < 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT, {\n      value: variant.__kind,\n      variants: variants.map(([key]) => key)\n    });\n  }\n  return discriminator;\n}\nfunction getTupleEncoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize === null ? {\n      getSizeFromValue: value => items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : {\n      fixedSize\n    }),\n    write: (value, bytes, offset) => {\n      assertValidNumberOfItemsForCodec(\"tuple\", items.length, value.length);\n      items.forEach((item, index) => {\n        offset = item.write(value[index], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getTupleDecoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize === null ? {\n      maxSize\n    } : {\n      fixedSize\n    }),\n    read: (bytes, offset) => {\n      const values = [];\n      items.forEach(item => {\n        const [newValue, newOffset] = item.read(bytes, offset);\n        values.push(newValue);\n        offset = newOffset;\n      });\n      return [values, offset];\n    }\n  });\n}\nfunction getTupleCodec(items) {\n  return combineCodec(getTupleEncoder(items), getTupleDecoder(items));\n}\n\n// src/map.ts\nfunction getMapEncoder(key, value, config = {}) {\n  return mapEncoder(getArrayEncoder(getTupleEncoder([key, value]), config), map => [...map.entries()]);\n}\nfunction getMapDecoder(key, value, config = {}) {\n  return mapDecoder(getArrayDecoder(getTupleDecoder([key, value]), config), entries => new Map(entries));\n}\nfunction getMapCodec(key, value, config = {}) {\n  return combineCodec(getMapEncoder(key, value, config), getMapDecoder(key, value, config));\n}\nfunction getNullableEncoder(item, config = {}) {\n  const prefix = config.prefix ?? getU8Encoder();\n  const fixed = config.fixed ?? false;\n  const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n  if (fixed || isZeroSizeItem) {\n    assertIsFixedSize(item);\n    assertIsFixedSize(prefix);\n    const fixedSize = prefix.fixedSize + item.fixedSize;\n    return createEncoder({\n      fixedSize,\n      write: (option, bytes, offset) => {\n        const prefixOffset = prefix.write(Number(option !== null), bytes, offset);\n        if (option !== null) {\n          item.write(option, bytes, prefixOffset);\n        }\n        return offset + fixedSize;\n      }\n    });\n  }\n  return createEncoder({\n    getSizeFromValue: option => getEncodedSize(Number(option !== null), prefix) + (option !== null ? getEncodedSize(option, item) : 0),\n    maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? void 0,\n    write: (option, bytes, offset) => {\n      offset = prefix.write(Number(option !== null), bytes, offset);\n      if (option !== null) {\n        offset = item.write(option, bytes, offset);\n      }\n      return offset;\n    }\n  });\n}\nfunction getNullableDecoder(item, config = {}) {\n  const prefix = config.prefix ?? getU8Decoder();\n  const fixed = config.fixed ?? false;\n  let fixedSize = null;\n  const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n  if (fixed || isZeroSizeItem) {\n    assertIsFixedSize(item);\n    assertIsFixedSize(prefix);\n    fixedSize = prefix.fixedSize + item.fixedSize;\n  }\n  return createDecoder({\n    ...(fixedSize === null ? {\n      maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? void 0\n    } : {\n      fixedSize\n    }),\n    read: (bytes, offset) => {\n      if (bytes.length - offset <= 0) {\n        return [null, offset];\n      }\n      const [isSome, prefixOffset] = prefix.read(bytes, offset);\n      if (isSome === 0) {\n        return [null, fixedSize !== null ? offset + fixedSize : prefixOffset];\n      }\n      const [value, newOffset] = item.read(bytes, prefixOffset);\n      return [value, fixedSize !== null ? offset + fixedSize : newOffset];\n    }\n  });\n}\nfunction getNullableCodec(item, config = {}) {\n  const configCast = config;\n  return combineCodec(getNullableEncoder(item, configCast), getNullableDecoder(item, configCast));\n}\nfunction getScalarEnumEncoder(constructor, config = {}) {\n  const prefix = config.size ?? getU8Encoder();\n  const {\n    minRange,\n    maxRange,\n    allStringInputs,\n    enumKeys,\n    enumValues\n  } = getScalarEnumStats(constructor);\n  return mapEncoder(prefix, value => {\n    const isInvalidNumber = typeof value === \"number\" && (value < minRange || value > maxRange);\n    const isInvalidString = typeof value === \"string\" && !allStringInputs.includes(value);\n    if (isInvalidNumber || isInvalidString) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT, {\n        maxRange,\n        minRange,\n        value,\n        variants: allStringInputs\n      });\n    }\n    if (typeof value === \"number\") return value;\n    const valueIndex = enumValues.indexOf(value);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.indexOf(value);\n  });\n}\nfunction getScalarEnumDecoder(constructor, config = {}) {\n  const prefix = config.size ?? getU8Decoder();\n  const {\n    minRange,\n    maxRange,\n    enumKeys\n  } = getScalarEnumStats(constructor);\n  return mapDecoder(prefix, value => {\n    const valueAsNumber = Number(value);\n    if (valueAsNumber < minRange || valueAsNumber > maxRange) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n        discriminator: valueAsNumber,\n        maxRange,\n        minRange\n      });\n    }\n    return constructor[enumKeys[valueAsNumber]];\n  });\n}\nfunction getScalarEnumCodec(constructor, config = {}) {\n  return combineCodec(getScalarEnumEncoder(constructor, config), getScalarEnumDecoder(constructor, config));\n}\nfunction getScalarEnumStats(constructor) {\n  const numericValues = Object.values(constructor).filter(v => typeof v === \"number\");\n  const deduplicatedConstructor = Object.fromEntries(Object.entries(constructor).slice(numericValues.length));\n  const enumKeys = Object.keys(deduplicatedConstructor);\n  const enumValues = Object.values(deduplicatedConstructor);\n  const minRange = 0;\n  const maxRange = enumValues.length - 1;\n  const allStringInputs = [... /* @__PURE__ */new Set([...enumKeys, ...enumValues.filter(v => typeof v === \"string\")])];\n  return {\n    allStringInputs,\n    enumKeys,\n    enumValues,\n    maxRange,\n    minRange\n  };\n}\nfunction getSetEncoder(item, config = {}) {\n  return mapEncoder(getArrayEncoder(item, config), set => [...set]);\n}\nfunction getSetDecoder(item, config = {}) {\n  return mapDecoder(getArrayDecoder(item, config), entries => new Set(entries));\n}\nfunction getSetCodec(item, config = {}) {\n  return combineCodec(getSetEncoder(item, config), getSetDecoder(item, config));\n}\nfunction getStructEncoder(fields) {\n  const fieldCodecs = fields.map(([, codec]) => codec);\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize === null ? {\n      getSizeFromValue: value => fields.map(([key, codec]) => getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : {\n      fixedSize\n    }),\n    write: (struct, bytes, offset) => {\n      fields.forEach(([key, codec]) => {\n        offset = codec.write(struct[key], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getStructDecoder(fields) {\n  const fieldCodecs = fields.map(([, codec]) => codec);\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize === null ? {\n      maxSize\n    } : {\n      fixedSize\n    }),\n    read: (bytes, offset) => {\n      const struct = {};\n      fields.forEach(([key, codec]) => {\n        const [value, newOffset] = codec.read(bytes, offset);\n        offset = newOffset;\n        struct[key] = value;\n      });\n      return [struct, offset];\n    }\n  });\n}\nfunction getStructCodec(fields) {\n  return combineCodec(getStructEncoder(fields), getStructDecoder(fields));\n}\nfunction getUnitEncoder() {\n  return createEncoder({\n    fixedSize: 0,\n    write: (_value, _bytes, offset) => offset\n  });\n}\nfunction getUnitDecoder() {\n  return createDecoder({\n    fixedSize: 0,\n    read: (_bytes, offset) => [void 0, offset]\n  });\n}\nfunction getUnitCodec() {\n  return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\nexport { assertValidNumberOfItemsForCodec, getArrayCodec, getArrayDecoder, getArrayEncoder, getBitArrayCodec, getBitArrayDecoder, getBitArrayEncoder, getBooleanCodec, getBooleanDecoder, getBooleanEncoder, getBytesCodec, getBytesDecoder, getBytesEncoder, getDataEnumCodec, getDataEnumDecoder, getDataEnumEncoder, getMapCodec, getMapDecoder, getMapEncoder, getNullableCodec, getNullableDecoder, getNullableEncoder, getScalarEnumCodec, getScalarEnumDecoder, getScalarEnumEncoder, getSetCodec, getSetDecoder, getSetEncoder, getStructCodec, getStructDecoder, getStructEncoder, getTupleCodec, getTupleDecoder, getTupleEncoder, getUnitCodec, getUnitDecoder, getUnitEncoder };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["getU32Encoder","getU32Decoder","getU8Encoder","getU8Decoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS","SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE","SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT","SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT","assertValidNumberOfItemsForCodec","codecDescription","expected","actual","maxCodecSizes","sizes","reduce","all","size","Math","max","getFixedSize","codec","isFixedSize","fixedSize","getMaxSize","maxSize","getArrayEncoder","item","config","computeArrayLikeCodecSize","createEncoder","getSizeFromValue","array","write","bytes","offset","length","forEach","value","getArrayDecoder","itemSize","createDecoder","read","slice","newOffset2","push","resolvedSize","newOffset","i","getArrayCodec","combineCodec","getBitArrayEncoder","parsedConfig","backward","bytesToAdd","byte","feature","j","unshift","set","getBitArrayDecoder","assertByteArrayHasEnoughBytesForCodec","booleans","reverse","Boolean","getBitArrayCodec","getBooleanEncoder","assertIsFixedSize","mapEncoder","getBooleanDecoder","mapDecoder","Number","getBooleanCodec","getBytesEncoder","byteEncoder","fixEncoder","getEncodedSize","getBytesDecoder","byteDecoder","fixDecoder","assertByteArrayIsNotEmptyForCodec","lengthBigInt","lengthOffset","contentBytes","contentOffset","getBytesCodec","getDataEnumEncoder","variants","prefix","getDataEnumFixedSize","variant","discriminator","getVariantDiscriminator","variantEncoder","getDataEnumMaxSize","getDataEnumDecoder","dOffset","variantField","maxRange","minRange","vOffset","__kind","getDataEnumCodec","variantSize","sameSizedVariants","every","maxVariantSize","map","sumCodecSizes","findIndex","key","getTupleEncoder","items","index","one","getTupleDecoder","values","newValue","getTupleCodec","getMapEncoder","entries","getMapDecoder","Map","getMapCodec","getNullableEncoder","isZeroSizeItem","fixed","option","prefixOffset","getNullableDecoder","isSome","configCast","getScalarEnumEncoder","constructor","allStringInputs","enumKeys","enumValues","getScalarEnumStats","isInvalidNumber","isInvalidString","includes","valueIndex","indexOf","getScalarEnumDecoder","valueAsNumber","getScalarEnumCodec","numericValues","Object","filter","v","deduplicatedConstructor","fromEntries","keys","Set","getSetEncoder","getSetDecoder","getSetCodec","getStructEncoder","fields","fieldCodecs","struct","getStructCodec","getStructDecoder","getUnitEncoder","_value","_bytes","getUnitDecoder","getUnitCodec","getNullableCodec"],"sources":["/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/array.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/assertions.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/utils.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/bit-array.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/boolean.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/bytes.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/data-enum.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/map.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/tuple.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/nullable.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/scalar-enum.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/set.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/struct.ts","/home/rochisha/solana-pay/node_modules/@solana/codecs-data-structures/src/unit.ts"],"sourcesContent":["import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Represents all the size options for array-like codecs\n * — i.e. `array`, `map` and `set`.\n *\n * It can be one of the following:\n * - a {@link NumberCodec} that prefixes its content with its size.\n * - a fixed number of items.\n * - or `'remainder'` to infer the number of items by dividing\n *   the rest of the byte array by the fixed size of its item.\n *   Note that this option is only available for fixed-size items.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/** Defines the configs for array codecs. */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Decodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an array of items.\n *\n * @param item - The codec to use for the array's items.\n * @param config - A set of config for the codec.\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/** Defines the config for bitArray codecs. */\nexport type BitArrayCodecConfig = {\n    /**\n     * Whether to read the bits in reverse order.\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Encodes an array of booleans into bits.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the encoder.\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Decodes bits into an array of booleans.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the decoder.\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * An array of boolean codec that converts booleans to bits and vice versa.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the codec.\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapDecoder,\n    mapEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/** Defines the config for boolean codecs. */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec to delegate to.\n     * @defaultValue u8 size.\n     */\n    size?: TSize;\n};\n\n/**\n * Encodes booleans.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): Encoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    const size = config.size ?? getU8Encoder();\n    assertIsFixedSize(size);\n    return mapEncoder(size, (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Decodes booleans.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): Decoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    const size = config.size ?? getU8Decoder();\n    assertIsFixedSize(size);\n    return mapDecoder(size, (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Creates a boolean codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): Codec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    fixDecoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\n/** Defines the config for bytes codecs. */\nexport type BytesCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the byte array. It can be one of the following:\n     * - a {@link NumberSerializer} that prefixes the byte array with its size.\n     * - a fixed number of bytes.\n     * - or `'variable'` to use the rest of the byte array.\n     * @defaultValue `'variable'`\n     */\n    size?: TSize | number | 'variable';\n};\n\n/**\n * Encodes sized bytes.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBytesEncoder<TSize extends number>(\n    config: BytesCodecConfig<NumberEncoder> & { size: TSize },\n): FixedSizeEncoder<Uint8Array, TSize>;\nexport function getBytesEncoder(config?: BytesCodecConfig<NumberEncoder>): VariableSizeEncoder<Uint8Array>;\nexport function getBytesEncoder(config: BytesCodecConfig<NumberEncoder> = {}): Encoder<Uint8Array> {\n    const size = config.size ?? 'variable';\n\n    const byteEncoder: Encoder<Uint8Array> = createEncoder({\n        getSizeFromValue: (value: Uint8Array) => value.length,\n        write: (value: Uint8Array, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n\n    if (size === 'variable') {\n        return byteEncoder;\n    }\n\n    if (typeof size === 'number') {\n        return fixEncoder(byteEncoder, size);\n    }\n\n    return createEncoder({\n        getSizeFromValue: (value: Uint8Array) => getEncodedSize(value.length, size) + value.length,\n        write: (value: Uint8Array, bytes, offset) => {\n            offset = size.write(value.length, bytes, offset);\n            return byteEncoder.write(value, bytes, offset);\n        },\n    });\n}\n\n/**\n * Decodes sized bytes.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBytesDecoder<TSize extends number>(\n    config: BytesCodecConfig<NumberDecoder> & { size: TSize },\n): FixedSizeDecoder<Uint8Array, TSize>;\nexport function getBytesDecoder(config?: BytesCodecConfig<NumberDecoder>): VariableSizeDecoder<Uint8Array>;\nexport function getBytesDecoder(config: BytesCodecConfig<NumberDecoder> = {}): Decoder<Uint8Array> {\n    const size = config.size ?? 'variable';\n\n    const byteDecoder: Decoder<Uint8Array> = createDecoder({\n        read: (bytes: Uint8Array, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n\n    if (size === 'variable') {\n        return byteDecoder;\n    }\n\n    if (typeof size === 'number') {\n        return fixDecoder(byteDecoder, size);\n    }\n\n    return createDecoder({\n        read: (bytes: Uint8Array, offset) => {\n            assertByteArrayIsNotEmptyForCodec('bytes', bytes, offset);\n            const [lengthBigInt, lengthOffset] = size.read(bytes, offset);\n            const length = Number(lengthBigInt);\n            offset = lengthOffset;\n            const contentBytes = bytes.slice(offset, offset + length);\n            assertByteArrayHasEnoughBytesForCodec('bytes', length, contentBytes);\n            const [value, contentOffset] = byteDecoder.read(contentBytes, 0);\n            offset += contentOffset;\n            return [value, offset];\n        },\n    });\n}\n\n/**\n * Creates a sized bytes codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBytesCodec<TSize extends number>(\n    config: BytesCodecConfig<NumberCodec> & { size: TSize },\n): FixedSizeCodec<Uint8Array, Uint8Array, TSize>;\nexport function getBytesCodec(config?: BytesCodecConfig<NumberCodec>): VariableSizeCodec<Uint8Array>;\nexport function getBytesCodec(config: BytesCodecConfig<NumberCodec> = {}): Codec<Uint8Array> {\n    return combineCodec(getBytesEncoder(config), getBytesDecoder(config));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    assertByteArrayIsNotEmptyForCodec,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n} from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport { getMaxSize, maxCodecSizes, sumCodecSizes } from './utils';\n\n/**\n * Defines a data enum using discriminated union types.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * ```\n */\nexport type DataEnum = { __kind: string };\n\n/**\n * Extracts a variant from a data enum.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDataEnumKind<WebPageEvent, 'click'>;\n * // -> { __kind: 'click', x: number, y: number }\n * ```\n */\nexport type GetDataEnumKind<T extends DataEnum, K extends T['__kind']> = Extract<T, { __kind: K }>;\n\n/**\n * Extracts a variant from a data enum without its discriminator.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDataEnumKindContent<WebPageEvent, 'click'>;\n * // -> { x: number, y: number }\n * ```\n */\nexport type GetDataEnumKindContent<T extends DataEnum, K extends T['__kind']> = Omit<\n    Extract<T, { __kind: K }>,\n    '__kind'\n>;\n\n/** Defines the config for data enum codecs. */\nexport type DataEnumCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator prefixing the variant.\n     * @defaultValue u8 prefix.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variants<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<TVariants extends Variants<Encoder<any>>> = {\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { __kind: TVariants[I][0] };\n}[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<TVariants extends Variants<Decoder<any>>> = {\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { __kind: TVariants[I][0] };\n}[ArrayIndices<TVariants>];\n\n/**\n * Creates a data enum encoder.\n *\n * @param variants - The variant encoders of the data enum.\n * @param config - A set of config for the encoder.\n */\nexport function getDataEnumEncoder<const TVariants extends Variants<Encoder<any>>>(\n    variants: TVariants,\n    config: DataEnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const prefix = config.size ?? getU8Encoder();\n    const fixedSize = getDataEnumFixedSize(variants, prefix);\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (variant: TFrom) => {\n                      const discriminator = getVariantDiscriminator(variants, variant);\n                      const variantEncoder = variants[discriminator][1];\n                      return (\n                          getEncodedSize(discriminator, prefix) +\n                          getEncodedSize(variant as TFrom & void, variantEncoder)\n                      );\n                  },\n                  maxSize: getDataEnumMaxSize(variants, prefix),\n              }),\n        write: (variant: TFrom, bytes, offset) => {\n            const discriminator = getVariantDiscriminator(variants, variant);\n            offset = prefix.write(discriminator, bytes, offset);\n            const variantEncoder = variants[discriminator][1];\n            return variantEncoder.write(variant as TFrom & void, bytes, offset);\n        },\n    });\n}\n\n/**\n * Creates a data enum decoder.\n *\n * @param variants - The variant decoders of the data enum.\n * @param config - A set of config for the decoder.\n */\nexport function getDataEnumDecoder<const TVariants extends Variants<Decoder<any>>>(\n    variants: TVariants,\n    config: DataEnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const prefix = config.size ?? getU8Decoder();\n    const fixedSize = getDataEnumFixedSize(variants, prefix);\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize: getDataEnumMaxSize(variants, prefix) }),\n        read: (bytes: Uint8Array, offset) => {\n            assertByteArrayIsNotEmptyForCodec('dataEnum', bytes, offset);\n            const [discriminator, dOffset] = prefix.read(bytes, offset);\n            offset = dOffset;\n            const variantField = variants[Number(discriminator)] ?? null;\n            if (!variantField) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                    discriminator,\n                    maxRange: variants.length - 1,\n                    minRange: 0,\n                });\n            }\n            const [variant, vOffset] = variantField[1].read(bytes, offset);\n            offset = vOffset;\n            return [{ __kind: variantField[0], ...(variant ?? {}) } as TTo, offset];\n        },\n    });\n}\n\n/**\n * Creates a data enum codec.\n *\n * @param variants - The variant codecs of the data enum.\n * @param config - A set of config for the codec.\n */\nexport function getDataEnumCodec<const TVariants extends Variants<Codec<any, any>>>(\n    variants: TVariants,\n    config: DataEnumCodecConfig<NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getDataEnumEncoder(variants, config),\n        getDataEnumDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction getDataEnumFixedSize<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    prefix: object | { fixedSize: number },\n): number | null {\n    if (variants.length === 0) return isFixedSize(prefix) ? prefix.fixedSize : null;\n    if (!isFixedSize(variants[0][1])) return null;\n    const variantSize = variants[0][1].fixedSize;\n    const sameSizedVariants = variants.every(\n        variant => isFixedSize(variant[1]) && variant[1].fixedSize === variantSize,\n    );\n    if (!sameSizedVariants) return null;\n    return isFixedSize(prefix) ? prefix.fixedSize + variantSize : null;\n}\n\nfunction getDataEnumMaxSize<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    prefix: object | { fixedSize: number },\n) {\n    const maxVariantSize = maxCodecSizes(variants.map(([, codec]) => getMaxSize(codec)));\n    return sumCodecSizes([getMaxSize(prefix), maxVariantSize]) ?? undefined;\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    variant: { __kind: string },\n) {\n    const discriminator = variants.findIndex(([key]) => variant.__kind === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DATA_ENUM_VARIANT, {\n            value: variant.__kind,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/** Defines the config for Map codecs. */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Creates a encoder for a map.\n *\n * @param key - The encoder to use for the map's keys.\n * @param value - The encoder to use for the map's values.\n * @param config - A set of config for the encoder.\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return mapEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Creates a decoder for a map.\n *\n * @param key - The decoder to use for the map's keys.\n * @param value - The decoder to use for the map's values.\n * @param config - A set of config for the decoder.\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return mapDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object),\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Creates a codec for a map.\n *\n * @param key - The codec to use for the map's keys.\n * @param value - The codec to use for the map's values.\n * @param config - A set of config for the codec.\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype WrapInFixedSizeEncoder<TFrom> = {\n    [P in keyof TFrom]: FixedSizeEncoder<TFrom[P]>;\n};\ntype WrapInEncoder<TFrom> = {\n    [P in keyof TFrom]: Encoder<TFrom[P]>;\n};\ntype WrapInFixedSizeDecoder<TTo> = {\n    [P in keyof TTo]: FixedSizeDecoder<TTo[P]>;\n};\ntype WrapInDecoder<TTo> = {\n    [P in keyof TTo]: Decoder<TTo[P]>;\n};\ntype WrapInCodec<TFrom, TTo extends TFrom> = {\n    [P in keyof TFrom]: Codec<TFrom[P], TTo[P]>;\n};\ntype WrapInFixedSizeCodec<TFrom, TTo extends TFrom> = {\n    [P in keyof TFrom]: FixedSizeCodec<TFrom[P], TTo[P]>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyArray = any[];\n\n/**\n * Creates a encoder for a tuple-like array.\n *\n * @param items - The encoders to use for each item in the tuple.\n */\nexport function getTupleEncoder<TFrom extends AnyArray>(\n    items: WrapInFixedSizeEncoder<[...TFrom]>,\n): FixedSizeEncoder<TFrom>;\nexport function getTupleEncoder<TFrom extends AnyArray>(items: WrapInEncoder<[...TFrom]>): VariableSizeEncoder<TFrom>;\nexport function getTupleEncoder<TFrom extends AnyArray>(items: WrapInEncoder<[...TFrom]>): Encoder<TFrom> {\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a tuple-like array.\n *\n * @param items - The decoders to use for each item in the tuple.\n */\nexport function getTupleDecoder<TTo extends AnyArray>(items: WrapInFixedSizeDecoder<[...TTo]>): FixedSizeDecoder<TTo>;\nexport function getTupleDecoder<TTo extends AnyArray>(items: WrapInDecoder<[...TTo]>): VariableSizeDecoder<TTo>;\nexport function getTupleDecoder<TTo extends AnyArray>(items: WrapInDecoder<[...TTo]>): Decoder<TTo> {\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: Uint8Array, offset) => {\n            const values = [] as AnyArray as TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a tuple-like array.\n *\n * @param items - The codecs to use for each item in the tuple.\n */\nexport function getTupleCodec<TFrom extends AnyArray, TTo extends TFrom = TFrom>(\n    items: WrapInFixedSizeCodec<[...TFrom], [...TTo]>,\n): FixedSizeCodec<TFrom, TTo>;\nexport function getTupleCodec<TFrom extends AnyArray, TTo extends TFrom = TFrom>(\n    items: WrapInCodec<[...TFrom], [...TTo]>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function getTupleCodec<TFrom extends AnyArray, TTo extends TFrom = TFrom>(\n    items: WrapInCodec<[...TFrom], [...TTo]>,\n): Codec<TFrom, TTo> {\n    return combineCodec(\n        getTupleEncoder(items as WrapInEncoder<[...TFrom]>),\n        getTupleDecoder(items as WrapInDecoder<[...TTo]>),\n    );\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getMaxSize, sumCodecSizes } from './utils';\n\n/** Defines the config for nullable codecs. */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Whether the item codec should be of fixed size.\n     *\n     * When this is true, a `null` value will skip the bytes that would\n     * have been used for the item. Note that this will only work if the\n     * item codec is of fixed size.\n     * @defaultValue `false`\n     */\n    fixed?: boolean;\n\n    /**\n     * The codec to use for the boolean prefix.\n     * @defaultValue u8 prefix.\n     */\n    prefix?: TPrefix;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { fixed: true },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom, 0>,\n    config?: NullableCodecConfig<FixedSizeNumberEncoder>,\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { fixed?: false },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = config.prefix ?? getU8Encoder();\n    const fixed = config.fixed ?? false;\n\n    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n    if (fixed || isZeroSizeItem) {\n        assertIsFixedSize(item);\n        assertIsFixedSize(prefix);\n        const fixedSize = prefix.fixedSize + item.fixedSize;\n        return createEncoder({\n            fixedSize,\n            write: (option: TFrom | null, bytes, offset) => {\n                const prefixOffset = prefix.write(Number(option !== null), bytes, offset);\n                if (option !== null) {\n                    item.write(option, bytes, prefixOffset);\n                }\n                return offset + fixedSize;\n            },\n        });\n    }\n\n    return createEncoder({\n        getSizeFromValue: (option: TFrom | null) =>\n            getEncodedSize(Number(option !== null), prefix) + (option !== null ? getEncodedSize(option, item) : 0),\n        maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? undefined,\n        write: (option: TFrom | null, bytes, offset) => {\n            offset = prefix.write(Number(option !== null), bytes, offset);\n            if (option !== null) {\n                offset = item.write(option, bytes, offset);\n            }\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { fixed: true },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo, 0>,\n    config?: NullableCodecConfig<FixedSizeNumberDecoder>,\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { fixed?: false },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = config.prefix ?? getU8Decoder();\n    const fixed = config.fixed ?? false;\n\n    let fixedSize: number | null = null;\n    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n    if (fixed || isZeroSizeItem) {\n        assertIsFixedSize(item);\n        assertIsFixedSize(prefix);\n        fixedSize = prefix.fixedSize + item.fixedSize;\n    }\n\n    return createDecoder({\n        ...(fixedSize === null\n            ? { maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? undefined }\n            : { fixedSize }),\n        read: (bytes: Uint8Array, offset) => {\n            if (bytes.length - offset <= 0) {\n                return [null, offset];\n            }\n            const [isSome, prefixOffset] = prefix.read(bytes, offset);\n            if (isSome === 0) {\n                return [null, fixedSize !== null ? offset + fixedSize : prefixOffset];\n            }\n            const [value, newOffset] = item.read(bytes, prefixOffset);\n            return [value, fixedSize !== null ? offset + fixedSize : newOffset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { fixed: true },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo, 0>,\n    config?: NullableCodecConfig<FixedSizeNumberCodec>,\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { fixed?: false },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    const configCast = config as NullableCodecConfig<NumberCodec> & { fixed?: false };\n    return combineCodec(getNullableEncoder<TFrom>(item, configCast), getNullableDecoder<TTo>(item, configCast));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the \"lookup object\" of a scalar enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type ScalarEnum = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for a scalar enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = ScalarEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type ScalarEnumFrom<TEnum extends ScalarEnum> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of a scalar enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = ScalarEnumFrom<Direction>; // 0 | 1\n * ```\n */\nexport type ScalarEnumTo<TEnum extends ScalarEnum> = TEnum[keyof TEnum];\n\n/** Defines the config for scalar enum codecs. */\nexport type ScalarEnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator.\n     * @defaultValue u8 discriminator.\n     */\n    size?: TDiscriminator;\n};\n\n/**\n * Creates a scalar enum encoder.\n *\n * @param constructor - The constructor of the scalar enum.\n * @param config - A set of config for the encoder.\n */\nexport function getScalarEnumEncoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n): FixedSizeEncoder<ScalarEnumFrom<TEnum>, 1>;\nexport function getScalarEnumEncoder<TEnum extends ScalarEnum, TSize extends number>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<ScalarEnumFrom<TEnum>, TSize>;\nexport function getScalarEnumEncoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config?: ScalarEnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<ScalarEnumFrom<TEnum>>;\nexport function getScalarEnumEncoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberEncoder> = {},\n): Encoder<ScalarEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const { minRange, maxRange, allStringInputs, enumKeys, enumValues } = getScalarEnumStats(constructor);\n    return mapEncoder(prefix, (value: ScalarEnumFrom<TEnum>): number => {\n        const isInvalidNumber = typeof value === 'number' && (value < minRange || value > maxRange);\n        const isInvalidString = typeof value === 'string' && !allStringInputs.includes(value);\n        if (isInvalidNumber || isInvalidString) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_SCALAR_ENUM_VARIANT, {\n                maxRange,\n                minRange,\n                value,\n                variants: allStringInputs,\n            });\n        }\n        if (typeof value === 'number') return value;\n        const valueIndex = enumValues.indexOf(value as string);\n        if (valueIndex >= 0) return valueIndex;\n        return enumKeys.indexOf(value as string);\n    });\n}\n\n/**\n * Creates a scalar enum decoder.\n *\n * @param constructor - The constructor of the scalar enum.\n * @param config - A set of config for the decoder.\n */\nexport function getScalarEnumDecoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n): FixedSizeDecoder<ScalarEnumTo<TEnum>, 1>;\nexport function getScalarEnumDecoder<TEnum extends ScalarEnum, TSize extends number>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<ScalarEnumTo<TEnum>, TSize>;\nexport function getScalarEnumDecoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config?: ScalarEnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<ScalarEnumTo<TEnum>>;\nexport function getScalarEnumDecoder<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberDecoder> = {},\n): Decoder<ScalarEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const { minRange, maxRange, enumKeys } = getScalarEnumStats(constructor);\n    return mapDecoder(prefix, (value: bigint | number): ScalarEnumTo<TEnum> => {\n        const valueAsNumber = Number(value);\n        if (valueAsNumber < minRange || valueAsNumber > maxRange) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: valueAsNumber,\n                maxRange,\n                minRange,\n            });\n        }\n        return constructor[enumKeys[valueAsNumber]] as ScalarEnumTo<TEnum>;\n    });\n}\n\n/**\n * Creates a scalar enum codec.\n *\n * @param constructor - The constructor of the scalar enum.\n * @param config - A set of config for the codec.\n */\nexport function getScalarEnumCodec<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n): FixedSizeCodec<ScalarEnumFrom<TEnum>, ScalarEnumTo<TEnum>, 1>;\nexport function getScalarEnumCodec<TEnum extends ScalarEnum, TSize extends number>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<ScalarEnumFrom<TEnum>, ScalarEnumTo<TEnum>, TSize>;\nexport function getScalarEnumCodec<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config?: ScalarEnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<ScalarEnumFrom<TEnum>, ScalarEnumTo<TEnum>>;\nexport function getScalarEnumCodec<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n    config: ScalarEnumCodecConfig<NumberCodec> = {},\n): Codec<ScalarEnumFrom<TEnum>, ScalarEnumTo<TEnum>> {\n    return combineCodec(getScalarEnumEncoder(constructor, config), getScalarEnumDecoder(constructor, config));\n}\n\nfunction getScalarEnumStats<TEnum extends ScalarEnum>(\n    constructor: TEnum,\n): {\n    allStringInputs: string[];\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    maxRange: number;\n    minRange: number;\n} {\n    const numericValues = Object.values(constructor).filter(v => typeof v === 'number') as number[];\n    const deduplicatedConstructor = Object.fromEntries(\n        Object.entries(constructor).slice(numericValues.length),\n    ) as Record<string, number | string>;\n    const enumKeys = Object.keys(deduplicatedConstructor);\n    const enumValues = Object.values(deduplicatedConstructor);\n    const minRange = 0;\n    const maxRange = enumValues.length - 1;\n    const allStringInputs: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return {\n        allStringInputs,\n        enumKeys,\n        enumValues,\n        maxRange,\n        minRange,\n    };\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/** Defines the config for set codecs. */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the set.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return mapEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Decodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return mapDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Creates a codec for an set of items.\n *\n * @param item - The codec to use for the set's items.\n * @param config - A set of config for the codec.\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype Fields<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = {\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n};\n\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = {\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n};\n\n/**\n * Creates a encoder for a custom object.\n *\n * @param fields - The name and encoder of each field.\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a custom object.\n *\n * @param fields - The name and decoder of each field.\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a custom object.\n *\n * @param fields - The name and codec of each field.\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Creates a void encoder.\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Creates a void decoder.\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Creates a void codec.\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
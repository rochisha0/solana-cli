{"ast":null,"code":"import { createTransferCheckedInstruction, getAccount, getAssociatedTokenAddress, getMint } from '@solana/spl-token';\nimport { LAMPORTS_PER_SOL, SystemProgram, Transaction, TransactionInstruction } from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID, SOL_DECIMALS, TEN } from './constants.js';\n/**\n * Thrown when a Solana Pay transfer transaction can't be created from the fields provided.\n */\nexport class CreateTransferError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'CreateTransferError';\n  }\n}\n/**\n * Create a Solana Pay transfer transaction.\n *\n * @param connection - A connection to the cluster.\n * @param sender - Account that will send the transfer.\n * @param fields - Fields of a Solana Pay transfer request URL.\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {CreateTransferError}\n */\nexport async function createTransfer(connection, sender, {\n  recipient,\n  amount,\n  splToken,\n  reference,\n  memo\n}, {\n  commitment\n} = {}) {\n  // Check that the sender and recipient accounts exist\n  const senderInfo = await connection.getAccountInfo(sender);\n  if (!senderInfo) throw new CreateTransferError('sender not found');\n  const recipientInfo = await connection.getAccountInfo(recipient);\n  if (!recipientInfo) throw new CreateTransferError('recipient not found');\n  // A native SOL or SPL token transfer instruction\n  const instruction = splToken ? await createSPLTokenInstruction(recipient, amount, splToken, sender, connection) : await createSystemInstruction(recipient, amount, sender, connection);\n  // If reference accounts are provided, add them to the transfer instruction\n  if (reference) {\n    if (!Array.isArray(reference)) {\n      reference = [reference];\n    }\n    for (const pubkey of reference) {\n      instruction.keys.push({\n        pubkey,\n        isWritable: false,\n        isSigner: false\n      });\n    }\n  }\n  // Create the transaction\n  const transaction = new Transaction();\n  transaction.feePayer = sender;\n  transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n  // If a memo is provided, add it to the transaction before adding the transfer instruction\n  if (memo != null) {\n    transaction.add(new TransactionInstruction({\n      programId: MEMO_PROGRAM_ID,\n      keys: [],\n      data: Buffer.from(memo, 'utf8')\n    }));\n  }\n  // Add the transfer instruction to the transaction\n  transaction.add(instruction);\n  return transaction;\n}\nasync function createSystemInstruction(recipient, amount, sender, connection) {\n  // Check that the sender and recipient accounts exist\n  const senderInfo = await connection.getAccountInfo(sender);\n  if (!senderInfo) throw new CreateTransferError('sender not found');\n  const recipientInfo = await connection.getAccountInfo(recipient);\n  if (!recipientInfo) throw new CreateTransferError('recipient not found');\n  // Check that the sender and recipient are valid native accounts\n  if (!senderInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('sender owner invalid');\n  if (senderInfo.executable) throw new CreateTransferError('sender executable');\n  if (!recipientInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('recipient owner invalid');\n  if (recipientInfo.executable) throw new CreateTransferError('recipient executable');\n  // Check that the amount provided doesn't have greater precision than SOL\n  if ((amount.decimalPlaces() ?? 0) > SOL_DECIMALS) throw new CreateTransferError('amount decimals invalid');\n  // Convert input decimal amount to integer lamports\n  amount = amount.times(LAMPORTS_PER_SOL).integerValue(BigNumber.ROUND_FLOOR);\n  // Check that the sender has enough lamports\n  const lamports = amount.toNumber();\n  if (lamports > senderInfo.lamports) throw new CreateTransferError('insufficient funds');\n  // Create an instruction to transfer native SOL\n  return SystemProgram.transfer({\n    fromPubkey: sender,\n    toPubkey: recipient,\n    lamports\n  });\n}\nasync function createSPLTokenInstruction(recipient, amount, splToken, sender, connection) {\n  // Check that the token provided is an initialized mint\n  const mint = await getMint(connection, splToken);\n  if (!mint.isInitialized) throw new CreateTransferError('mint not initialized');\n  // Check that the amount provided doesn't have greater precision than the mint\n  if ((amount.decimalPlaces() ?? 0) > mint.decimals) throw new CreateTransferError('amount decimals invalid');\n  // Convert input decimal amount to integer tokens according to the mint decimals\n  amount = amount.times(TEN.pow(mint.decimals)).integerValue(BigNumber.ROUND_FLOOR);\n  // Get the sender's ATA and check that the account exists and can send tokens\n  const senderATA = await getAssociatedTokenAddress(splToken, sender);\n  const senderAccount = await getAccount(connection, senderATA);\n  if (!senderAccount.isInitialized) throw new CreateTransferError('sender not initialized');\n  if (senderAccount.isFrozen) throw new CreateTransferError('sender frozen');\n  // Get the recipient's ATA and check that the account exists and can receive tokens\n  const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n  const recipientAccount = await getAccount(connection, recipientATA);\n  if (!recipientAccount.isInitialized) throw new CreateTransferError('recipient not initialized');\n  if (recipientAccount.isFrozen) throw new CreateTransferError('recipient frozen');\n  // Check that the sender has enough tokens\n  const tokens = BigInt(String(amount));\n  if (tokens > senderAccount.amount) throw new CreateTransferError('insufficient funds');\n  // Create an instruction to transfer SPL tokens, asserting the mint and decimals match\n  return createTransferCheckedInstruction(senderATA, splToken, recipientATA, sender, tokens, mint.decimals);\n}","map":{"version":3,"names":["createTransferCheckedInstruction","getAccount","getAssociatedTokenAddress","getMint","LAMPORTS_PER_SOL","SystemProgram","Transaction","TransactionInstruction","BigNumber","MEMO_PROGRAM_ID","SOL_DECIMALS","TEN","CreateTransferError","Error","constructor","name","createTransfer","connection","sender","recipient","amount","splToken","reference","memo","commitment","senderInfo","getAccountInfo","recipientInfo","instruction","createSPLTokenInstruction","createSystemInstruction","Array","isArray","pubkey","keys","push","isWritable","isSigner","transaction","feePayer","recentBlockhash","getRecentBlockhash","blockhash","add","programId","data","Buffer","from","owner","equals","executable","decimalPlaces","times","integerValue","ROUND_FLOOR","lamports","toNumber","transfer","fromPubkey","toPubkey","mint","isInitialized","decimals","pow","senderATA","senderAccount","isFrozen","recipientATA","recipientAccount","tokens","BigInt","String"],"sources":["/home/rochisha/solana-pay/node_modules/@solana/pay/src/createTransfer.ts"],"sourcesContent":["import { createTransferCheckedInstruction, getAccount, getAssociatedTokenAddress, getMint } from '@solana/spl-token';\nimport type { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { LAMPORTS_PER_SOL, SystemProgram, Transaction, TransactionInstruction } from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID, SOL_DECIMALS, TEN } from './constants.js';\nimport type { Amount, Memo, Recipient, References, SPLToken } from './types.js';\n\n/**\n * Thrown when a Solana Pay transfer transaction can't be created from the fields provided.\n */\nexport class CreateTransferError extends Error {\n    name = 'CreateTransferError';\n}\n\n/**\n * Fields of a Solana Pay transfer request URL.\n */\nexport interface CreateTransferFields {\n    /** `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient). */\n    recipient: Recipient;\n    /** `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount). */\n    amount: Amount;\n    /** `spl-token` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#spl-token). */\n    splToken?: SPLToken;\n    /** `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference). */\n    reference?: References;\n    /** `memo` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#memo). */\n    memo?: Memo;\n}\n\n/**\n * Create a Solana Pay transfer transaction.\n *\n * @param connection - A connection to the cluster.\n * @param sender - Account that will send the transfer.\n * @param fields - Fields of a Solana Pay transfer request URL.\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {CreateTransferError}\n */\nexport async function createTransfer(\n    connection: Connection,\n    sender: PublicKey,\n    { recipient, amount, splToken, reference, memo }: CreateTransferFields,\n    { commitment }: { commitment?: Commitment } = {}\n): Promise<Transaction> {\n    // Check that the sender and recipient accounts exist\n    const senderInfo = await connection.getAccountInfo(sender);\n    if (!senderInfo) throw new CreateTransferError('sender not found');\n\n    const recipientInfo = await connection.getAccountInfo(recipient);\n    if (!recipientInfo) throw new CreateTransferError('recipient not found');\n\n    // A native SOL or SPL token transfer instruction\n    const instruction = splToken\n        ? await createSPLTokenInstruction(recipient, amount, splToken, sender, connection)\n        : await createSystemInstruction(recipient, amount, sender, connection);\n\n    // If reference accounts are provided, add them to the transfer instruction\n    if (reference) {\n        if (!Array.isArray(reference)) {\n            reference = [reference];\n        }\n\n        for (const pubkey of reference) {\n            instruction.keys.push({ pubkey, isWritable: false, isSigner: false });\n        }\n    }\n\n    // Create the transaction\n    const transaction = new Transaction();\n    transaction.feePayer = sender;\n    transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n\n    // If a memo is provided, add it to the transaction before adding the transfer instruction\n    if (memo != null) {\n        transaction.add(\n            new TransactionInstruction({\n                programId: MEMO_PROGRAM_ID,\n                keys: [],\n                data: Buffer.from(memo, 'utf8'),\n            })\n        );\n    }\n\n    // Add the transfer instruction to the transaction\n    transaction.add(instruction);\n\n    return transaction;\n}\n\nasync function createSystemInstruction(\n    recipient: PublicKey,\n    amount: BigNumber,\n    sender: PublicKey,\n    connection: Connection\n): Promise<TransactionInstruction> {\n    // Check that the sender and recipient accounts exist\n    const senderInfo = await connection.getAccountInfo(sender);\n    if (!senderInfo) throw new CreateTransferError('sender not found');\n\n    const recipientInfo = await connection.getAccountInfo(recipient);\n    if (!recipientInfo) throw new CreateTransferError('recipient not found');\n\n    // Check that the sender and recipient are valid native accounts\n    if (!senderInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('sender owner invalid');\n    if (senderInfo.executable) throw new CreateTransferError('sender executable');\n    if (!recipientInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('recipient owner invalid');\n    if (recipientInfo.executable) throw new CreateTransferError('recipient executable');\n\n    // Check that the amount provided doesn't have greater precision than SOL\n    if ((amount.decimalPlaces() ?? 0) > SOL_DECIMALS) throw new CreateTransferError('amount decimals invalid');\n\n    // Convert input decimal amount to integer lamports\n    amount = amount.times(LAMPORTS_PER_SOL).integerValue(BigNumber.ROUND_FLOOR);\n\n    // Check that the sender has enough lamports\n    const lamports = amount.toNumber();\n    if (lamports > senderInfo.lamports) throw new CreateTransferError('insufficient funds');\n\n    // Create an instruction to transfer native SOL\n    return SystemProgram.transfer({\n        fromPubkey: sender,\n        toPubkey: recipient,\n        lamports,\n    });\n}\n\nasync function createSPLTokenInstruction(\n    recipient: PublicKey,\n    amount: BigNumber,\n    splToken: PublicKey,\n    sender: PublicKey,\n    connection: Connection\n): Promise<TransactionInstruction> {\n    // Check that the token provided is an initialized mint\n    const mint = await getMint(connection, splToken);\n    if (!mint.isInitialized) throw new CreateTransferError('mint not initialized');\n\n    // Check that the amount provided doesn't have greater precision than the mint\n    if ((amount.decimalPlaces() ?? 0) > mint.decimals) throw new CreateTransferError('amount decimals invalid');\n\n    // Convert input decimal amount to integer tokens according to the mint decimals\n    amount = amount.times(TEN.pow(mint.decimals)).integerValue(BigNumber.ROUND_FLOOR);\n\n    // Get the sender's ATA and check that the account exists and can send tokens\n    const senderATA = await getAssociatedTokenAddress(splToken, sender);\n    const senderAccount = await getAccount(connection, senderATA);\n    if (!senderAccount.isInitialized) throw new CreateTransferError('sender not initialized');\n    if (senderAccount.isFrozen) throw new CreateTransferError('sender frozen');\n\n    // Get the recipient's ATA and check that the account exists and can receive tokens\n    const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n    const recipientAccount = await getAccount(connection, recipientATA);\n    if (!recipientAccount.isInitialized) throw new CreateTransferError('recipient not initialized');\n    if (recipientAccount.isFrozen) throw new CreateTransferError('recipient frozen');\n\n    // Check that the sender has enough tokens\n    const tokens = BigInt(String(amount));\n    if (tokens > senderAccount.amount) throw new CreateTransferError('insufficient funds');\n\n    // Create an instruction to transfer SPL tokens, asserting the mint and decimals match\n    return createTransferCheckedInstruction(senderATA, splToken, recipientATA, sender, tokens, mint.decimals);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
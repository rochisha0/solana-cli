{"ast":null,"code":"import { createEncoder, getEncodedSize, createDecoder, combineCodec, assertByteArrayHasEnoughBytesForCodec, transformEncoder, transformDecoder, containsBytes, isFixedSize, assertIsFixedSize, fixEncoderSize, fixDecoderSize } from '@solana/codecs-core';\nimport { getU32Encoder, getU32Decoder, getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SolanaError, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__INVALID_CONSTANT, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE } from '@solana/errors';\n\n// src/array.ts\nfunction assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {\n  if (expected !== actual) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n      actual,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction maxCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : Math.max(all, size), 0);\n}\nfunction sumCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);\n}\nfunction getFixedSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : null;\n}\nfunction getMaxSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n\n// src/array.ts\nfunction getArrayEncoder(item, config = {}) {\n  const size = config.size ?? getU32Encoder();\n  const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize !== null ? {\n      fixedSize\n    } : {\n      getSizeFromValue: array => {\n        const prefixSize = typeof size === \"object\" ? getEncodedSize(array.length, size) : 0;\n        return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n      },\n      maxSize\n    }),\n    write: (array, bytes, offset) => {\n      if (typeof size === \"number\") {\n        assertValidNumberOfItemsForCodec(\"array\", size, array.length);\n      }\n      if (typeof size === \"object\") {\n        offset = size.write(array.length, bytes, offset);\n      }\n      array.forEach(value => {\n        offset = item.write(value, bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getArrayDecoder(item, config = {}) {\n  const size = config.size ?? getU32Decoder();\n  const itemSize = getFixedSize(item);\n  const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize !== null ? {\n      fixedSize\n    } : {\n      maxSize\n    }),\n    read: (bytes, offset) => {\n      const array = [];\n      if (typeof size === \"object\" && bytes.slice(offset).length === 0) {\n        return [array, offset];\n      }\n      if (size === \"remainder\") {\n        while (offset < bytes.length) {\n          const [value, newOffset2] = item.read(bytes, offset);\n          offset = newOffset2;\n          array.push(value);\n        }\n        return [array, offset];\n      }\n      const [resolvedSize, newOffset] = typeof size === \"number\" ? [size, offset] : size.read(bytes, offset);\n      offset = newOffset;\n      for (let i = 0; i < resolvedSize; i += 1) {\n        const [value, newOffset2] = item.read(bytes, offset);\n        offset = newOffset2;\n        array.push(value);\n      }\n      return [array, offset];\n    }\n  });\n}\nfunction getArrayCodec(item, config = {}) {\n  return combineCodec(getArrayEncoder(item, config), getArrayDecoder(item, config));\n}\nfunction computeArrayLikeCodecSize(size, itemSize) {\n  if (typeof size !== \"number\") return null;\n  if (size === 0) return 0;\n  return itemSize === null ? null : itemSize * size;\n}\nfunction getBitArrayEncoder(size, config = {}) {\n  const parsedConfig = typeof config === \"boolean\" ? {\n    backward: config\n  } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createEncoder({\n    fixedSize: size,\n    write(value, bytes, offset) {\n      const bytesToAdd = [];\n      for (let i = 0; i < size; i += 1) {\n        let byte = 0;\n        for (let j = 0; j < 8; j += 1) {\n          const feature = Number(value[i * 8 + j] ?? 0);\n          byte |= feature << (backward ? j : 7 - j);\n        }\n        if (backward) {\n          bytesToAdd.unshift(byte);\n        } else {\n          bytesToAdd.push(byte);\n        }\n      }\n      bytes.set(bytesToAdd, offset);\n      return size;\n    }\n  });\n}\nfunction getBitArrayDecoder(size, config = {}) {\n  const parsedConfig = typeof config === \"boolean\" ? {\n    backward: config\n  } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createDecoder({\n    fixedSize: size,\n    read(bytes, offset) {\n      assertByteArrayHasEnoughBytesForCodec(\"bitArray\", size, bytes, offset);\n      const booleans = [];\n      let slice = bytes.slice(offset, offset + size);\n      slice = backward ? slice.reverse() : slice;\n      slice.forEach(byte => {\n        for (let i = 0; i < 8; i += 1) {\n          if (backward) {\n            booleans.push(Boolean(byte & 1));\n            byte >>= 1;\n          } else {\n            booleans.push(Boolean(byte & 128));\n            byte <<= 1;\n          }\n        }\n      });\n      return [booleans, offset + size];\n    }\n  });\n}\nfunction getBitArrayCodec(size, config = {}) {\n  return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\nfunction getBooleanEncoder(config = {}) {\n  return transformEncoder(config.size ?? getU8Encoder(), value => value ? 1 : 0);\n}\nfunction getBooleanDecoder(config = {}) {\n  return transformDecoder(config.size ?? getU8Decoder(), value => Number(value) === 1);\n}\nfunction getBooleanCodec(config = {}) {\n  return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\nfunction getBytesEncoder() {\n  return createEncoder({\n    getSizeFromValue: value => value.length,\n    write: (value, bytes, offset) => {\n      bytes.set(value, offset);\n      return offset + value.length;\n    }\n  });\n}\nfunction getBytesDecoder() {\n  return createDecoder({\n    read: (bytes, offset) => {\n      const slice = bytes.slice(offset);\n      return [slice, offset + slice.length];\n    }\n  });\n}\nfunction getBytesCodec() {\n  return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nfunction getConstantEncoder(constant) {\n  return createEncoder({\n    fixedSize: constant.length,\n    write: (_, bytes, offset) => {\n      bytes.set(constant, offset);\n      return offset + constant.length;\n    }\n  });\n}\nfunction getConstantDecoder(constant) {\n  return createDecoder({\n    fixedSize: constant.length,\n    read: (bytes, offset) => {\n      const base16 = getBase16Decoder();\n      if (!containsBytes(bytes, constant, offset)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n          constant,\n          data: bytes,\n          hexConstant: base16.decode(constant),\n          hexData: base16.decode(bytes),\n          offset\n        });\n      }\n      return [void 0, offset + constant.length];\n    }\n  });\n}\nfunction getConstantCodec(constant) {\n  return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\nfunction getTupleEncoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize === null ? {\n      getSizeFromValue: value => items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : {\n      fixedSize\n    }),\n    write: (value, bytes, offset) => {\n      assertValidNumberOfItemsForCodec(\"tuple\", items.length, value.length);\n      items.forEach((item, index) => {\n        offset = item.write(value[index], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getTupleDecoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize === null ? {\n      maxSize\n    } : {\n      fixedSize\n    }),\n    read: (bytes, offset) => {\n      const values = [];\n      items.forEach(item => {\n        const [newValue, newOffset] = item.read(bytes, offset);\n        values.push(newValue);\n        offset = newOffset;\n      });\n      return [values, offset];\n    }\n  });\n}\nfunction getTupleCodec(items) {\n  return combineCodec(getTupleEncoder(items), getTupleDecoder(items));\n}\nfunction getUnionEncoder(variants, getIndexFromValue) {\n  const fixedSize = getUnionFixedSize(variants);\n  const write = (variant, bytes, offset) => {\n    const index = getIndexFromValue(variant);\n    assertValidVariantIndex(variants, index);\n    return variants[index].write(variant, bytes, offset);\n  };\n  if (fixedSize !== null) {\n    return createEncoder({\n      fixedSize,\n      write\n    });\n  }\n  const maxSize = getUnionMaxSize(variants);\n  return createEncoder({\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    getSizeFromValue: variant => {\n      const index = getIndexFromValue(variant);\n      assertValidVariantIndex(variants, index);\n      return getEncodedSize(variant, variants[index]);\n    },\n    write\n  });\n}\nfunction getUnionDecoder(variants, getIndexFromBytes) {\n  const fixedSize = getUnionFixedSize(variants);\n  const read = (bytes, offset) => {\n    const index = getIndexFromBytes(bytes, offset);\n    assertValidVariantIndex(variants, index);\n    return variants[index].read(bytes, offset);\n  };\n  if (fixedSize !== null) {\n    return createDecoder({\n      fixedSize,\n      read\n    });\n  }\n  const maxSize = getUnionMaxSize(variants);\n  return createDecoder({\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    read\n  });\n}\nfunction getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {\n  return combineCodec(getUnionEncoder(variants, getIndexFromValue), getUnionDecoder(variants, getIndexFromBytes));\n}\nfunction assertValidVariantIndex(variants, index) {\n  if (typeof variants[index] === \"undefined\") {\n    throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n      maxRange: variants.length - 1,\n      minRange: 0,\n      variant: index\n    });\n  }\n}\nfunction getUnionFixedSize(variants) {\n  if (variants.length === 0) return 0;\n  if (!isFixedSize(variants[0])) return null;\n  const variantSize = variants[0].fixedSize;\n  const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n  return sameSizedVariants ? variantSize : null;\n}\nfunction getUnionMaxSize(variants) {\n  return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n\n// src/discriminated-union.ts\nfunction getDiscriminatedUnionEncoder(variants, config = {}) {\n  const discriminatorProperty = config.discriminator ?? \"__kind\";\n  const prefix = config.size ?? getU8Encoder();\n  return getUnionEncoder(variants.map(([, variant], index) => transformEncoder(getTupleEncoder([prefix, variant]), value => [index, value])), value => getVariantDiscriminator(variants, value[discriminatorProperty]));\n}\nfunction getDiscriminatedUnionDecoder(variants, config = {}) {\n  const discriminatorProperty = config.discriminator ?? \"__kind\";\n  const prefix = config.size ?? getU8Decoder();\n  return getUnionDecoder(variants.map(([discriminator, variant]) => transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n    [discriminatorProperty]: discriminator,\n    ...value\n  }))), (bytes, offset) => Number(prefix.read(bytes, offset)[0]));\n}\nfunction getDiscriminatedUnionCodec(variants, config = {}) {\n  return combineCodec(getDiscriminatedUnionEncoder(variants, config), getDiscriminatedUnionDecoder(variants, config));\n}\nfunction getVariantDiscriminator(variants, discriminatorValue) {\n  const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n  if (discriminator < 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n      value: discriminatorValue,\n      variants: variants.map(([key]) => key)\n    });\n  }\n  return discriminator;\n}\nvar getDataEnumEncoder = getDiscriminatedUnionEncoder;\nvar getDataEnumDecoder = getDiscriminatedUnionDecoder;\nvar getDataEnumCodec = getDiscriminatedUnionCodec;\n\n// src/enum-helpers.ts\nfunction getEnumStats(constructor) {\n  const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === \"number\"))].sort();\n  const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));\n  const enumKeys = Object.keys(enumRecord);\n  const enumValues = Object.values(enumRecord);\n  const stringValues = [... /* @__PURE__ */new Set([...enumKeys, ...enumValues.filter(v => typeof v === \"string\")])];\n  return {\n    enumKeys,\n    enumRecord,\n    enumValues,\n    numericalValues,\n    stringValues\n  };\n}\nfunction getEnumIndexFromVariant({\n  enumKeys,\n  enumValues,\n  variant\n}) {\n  const valueIndex = findLastIndex(enumValues, value => value === variant);\n  if (valueIndex >= 0) return valueIndex;\n  return enumKeys.findIndex(key => key === variant);\n}\nfunction getEnumIndexFromDiscriminator({\n  discriminator,\n  enumKeys,\n  enumValues,\n  useValuesAsDiscriminators\n}) {\n  if (!useValuesAsDiscriminators) {\n    return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n  }\n  return findLastIndex(enumValues, value => value === discriminator);\n}\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n  while (l--) {\n    if (predicate(array[l], l, array)) return l;\n  }\n  return -1;\n}\nfunction formatNumericalValues(values) {\n  if (values.length === 0) return \"\";\n  let range = [values[0], values[0]];\n  const ranges = [];\n  for (let index = 1; index < values.length; index++) {\n    const value = values[index];\n    if (range[1] + 1 === value) {\n      range[1] = value;\n    } else {\n      ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n      range = [value, value];\n    }\n  }\n  ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n  return ranges.join(\", \");\n}\n\n// src/enum.ts\nfunction getEnumEncoder(constructor, config = {}) {\n  const prefix = config.size ?? getU8Encoder();\n  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n  const {\n    enumKeys,\n    enumValues,\n    numericalValues,\n    stringValues\n  } = getEnumStats(constructor);\n  if (useValuesAsDiscriminators && enumValues.some(value => typeof value === \"string\")) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n      stringValues: enumValues.filter(v => typeof v === \"string\")\n    });\n  }\n  return transformEncoder(prefix, variant => {\n    const index = getEnumIndexFromVariant({\n      enumKeys,\n      enumValues,\n      variant\n    });\n    if (index < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n        formattedNumericalValues: formatNumericalValues(numericalValues),\n        numericalValues,\n        stringValues,\n        variant\n      });\n    }\n    return useValuesAsDiscriminators ? enumValues[index] : index;\n  });\n}\nfunction getEnumDecoder(constructor, config = {}) {\n  const prefix = config.size ?? getU8Decoder();\n  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n  const {\n    enumKeys,\n    enumValues,\n    numericalValues\n  } = getEnumStats(constructor);\n  if (useValuesAsDiscriminators && enumValues.some(value => typeof value === \"string\")) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n      stringValues: enumValues.filter(v => typeof v === \"string\")\n    });\n  }\n  return transformDecoder(prefix, value => {\n    const discriminator = Number(value);\n    const index = getEnumIndexFromDiscriminator({\n      discriminator,\n      enumKeys,\n      enumValues,\n      useValuesAsDiscriminators\n    });\n    if (index < 0) {\n      const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n        discriminator,\n        formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n        validDiscriminators\n      });\n    }\n    return enumValues[index];\n  });\n}\nfunction getEnumCodec(constructor, config = {}) {\n  return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\nvar getScalarEnumEncoder = getEnumEncoder;\nvar getScalarEnumDecoder = getEnumDecoder;\nvar getScalarEnumCodec = getEnumCodec;\nfunction getHiddenPrefixEncoder(encoder, prefixedEncoders) {\n  return transformEncoder(getTupleEncoder([...prefixedEncoders, encoder]), value => [...prefixedEncoders.map(() => void 0), value]);\n}\nfunction getHiddenPrefixDecoder(decoder, prefixedDecoders) {\n  return transformDecoder(getTupleDecoder([...prefixedDecoders, decoder]), tuple => tuple[tuple.length - 1]);\n}\nfunction getHiddenPrefixCodec(codec, prefixedCodecs) {\n  return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\nfunction getHiddenSuffixEncoder(encoder, suffixedEncoders) {\n  return transformEncoder(getTupleEncoder([encoder, ...suffixedEncoders]), value => [value, ...suffixedEncoders.map(() => void 0)]);\n}\nfunction getHiddenSuffixDecoder(decoder, suffixedDecoders) {\n  return transformDecoder(getTupleDecoder([decoder, ...suffixedDecoders]), tuple => tuple[0]);\n}\nfunction getHiddenSuffixCodec(codec, suffixedCodecs) {\n  return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\nfunction getMapEncoder(key, value, config = {}) {\n  return transformEncoder(getArrayEncoder(getTupleEncoder([key, value]), config), map => [...map.entries()]);\n}\nfunction getMapDecoder(key, value, config = {}) {\n  return transformDecoder(getArrayDecoder(getTupleDecoder([key, value]), config), entries => new Map(entries));\n}\nfunction getMapCodec(key, value, config = {}) {\n  return combineCodec(getMapEncoder(key, value, config), getMapDecoder(key, value, config));\n}\nfunction getUnitEncoder() {\n  return createEncoder({\n    fixedSize: 0,\n    write: (_value, _bytes, offset) => offset\n  });\n}\nfunction getUnitDecoder() {\n  return createDecoder({\n    fixedSize: 0,\n    read: (_bytes, offset) => [void 0, offset]\n  });\n}\nfunction getUnitCodec() {\n  return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n\n// src/nullable.ts\nfunction getNullableEncoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformEncoder(getUnitEncoder(), _boolean => void 0);\n    }\n    return getBooleanEncoder({\n      size: config.prefix ?? getU8Encoder()\n    });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitEncoder();\n    }\n    return getConstantEncoder(config.noneValue);\n  })();\n  return getUnionEncoder([transformEncoder(getTupleEncoder([prefix, noneValue]), _value => [false, void 0]), transformEncoder(getTupleEncoder([prefix, item]), value => [true, value])], variant => Number(variant !== null));\n}\nfunction getNullableDecoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformDecoder(getUnitDecoder(), () => false);\n    }\n    return getBooleanDecoder({\n      size: config.prefix ?? getU8Decoder()\n    });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitDecoder();\n    }\n    return getConstantDecoder(config.noneValue);\n  })();\n  return getUnionDecoder([transformDecoder(getTupleDecoder([prefix, noneValue]), () => null), transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => value)], (bytes, offset) => {\n    if (config.prefix === null && !config.noneValue) {\n      return Number(offset < bytes.length);\n    }\n    if (config.prefix === null && config.noneValue != null) {\n      const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n      return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n    }\n    return Number(prefix.read(bytes, offset)[0]);\n  });\n}\nfunction getNullableCodec(item, config = {}) {\n  return combineCodec(getNullableEncoder(item, config), getNullableDecoder(item, config));\n}\nfunction getSetEncoder(item, config = {}) {\n  return transformEncoder(getArrayEncoder(item, config), set => [...set]);\n}\nfunction getSetDecoder(item, config = {}) {\n  return transformDecoder(getArrayDecoder(item, config), entries => new Set(entries));\n}\nfunction getSetCodec(item, config = {}) {\n  return combineCodec(getSetEncoder(item, config), getSetDecoder(item, config));\n}\nfunction getStructEncoder(fields) {\n  const fieldCodecs = fields.map(([, codec]) => codec);\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...(fixedSize === null ? {\n      getSizeFromValue: value => fields.map(([key, codec]) => getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : {\n      fixedSize\n    }),\n    write: (struct, bytes, offset) => {\n      fields.forEach(([key, codec]) => {\n        offset = codec.write(struct[key], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getStructDecoder(fields) {\n  const fieldCodecs = fields.map(([, codec]) => codec);\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...(fixedSize === null ? {\n      maxSize\n    } : {\n      fixedSize\n    }),\n    read: (bytes, offset) => {\n      const struct = {};\n      fields.forEach(([key, codec]) => {\n        const [value, newOffset] = codec.read(bytes, offset);\n        offset = newOffset;\n        struct[key] = value;\n      });\n      return [struct, offset];\n    }\n  });\n}\nfunction getStructCodec(fields) {\n  return combineCodec(getStructEncoder(fields), getStructDecoder(fields));\n}\nexport { assertValidNumberOfItemsForCodec, getArrayCodec, getArrayDecoder, getArrayEncoder, getBitArrayCodec, getBitArrayDecoder, getBitArrayEncoder, getBooleanCodec, getBooleanDecoder, getBooleanEncoder, getBytesCodec, getBytesDecoder, getBytesEncoder, getConstantCodec, getConstantDecoder, getConstantEncoder, getDataEnumCodec, getDataEnumDecoder, getDataEnumEncoder, getDiscriminatedUnionCodec, getDiscriminatedUnionDecoder, getDiscriminatedUnionEncoder, getEnumCodec, getEnumDecoder, getEnumEncoder, getHiddenPrefixCodec, getHiddenPrefixDecoder, getHiddenPrefixEncoder, getHiddenSuffixCodec, getHiddenSuffixDecoder, getHiddenSuffixEncoder, getMapCodec, getMapDecoder, getMapEncoder, getNullableCodec, getNullableDecoder, getNullableEncoder, getScalarEnumCodec, getScalarEnumDecoder, getScalarEnumEncoder, getSetCodec, getSetDecoder, getSetEncoder, getStructCodec, getStructDecoder, getStructEncoder, getTupleCodec, getTupleDecoder, getTupleEncoder, getUnionCodec, getUnionDecoder, getUnionEncoder, getUnitCodec, getUnitDecoder, getUnitEncoder };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["getU32Encoder","getU32Decoder","getU8Encoder","getU8Decoder","SolanaError","SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS","SOLANA_ERROR__CODECS__INVALID_CONSTANT","SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE","SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT","SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS","SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT","SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE","assertValidNumberOfItemsForCodec","codecDescription","expected","actual","maxCodecSizes","sizes","reduce","all","size","Math","max","getFixedSize","codec","isFixedSize","fixedSize","getMaxSize","maxSize","getArrayEncoder","item","config","computeArrayLikeCodecSize","createEncoder","getSizeFromValue","array","write","bytes","offset","length","forEach","value","getArrayDecoder","itemSize","createDecoder","read","slice","newOffset2","push","resolvedSize","newOffset","i","getArrayCodec","combineCodec","getBitArrayEncoder","parsedConfig","backward","bytesToAdd","byte","feature","j","unshift","set","getBitArrayDecoder","assertByteArrayHasEnoughBytesForCodec","booleans","reverse","Boolean","getBitArrayCodec","getBooleanEncoder","transformEncoder","getBooleanDecoder","transformDecoder","Number","getBooleanCodec","getBytesEncoder","getBytesCodec","getBytesDecoder","getBase16Decoder","str","toString","padStart","getConstantEncoder","constant","getConstantDecoder","base16","containsBytes","data","hexConstant","decode","hexData","getConstantCodec","sumCodecSizes","items","map","index","getEncodedSize","one","getTupleDecoder","values","newValue","getTupleCodec","getTupleEncoder","getUnionEncoder","variants","getIndexFromValue","getUnionFixedSize","variant","assertValidVariantIndex","getUnionMaxSize","getUnionDecoder","getIndexFromBytes","getUnionCodec","maxRange","minRange","variantSize","sameSizedVariants","every","getDiscriminatedUnionEncoder","discriminatorProperty","discriminator","prefix","getVariantDiscriminator","getDiscriminatedUnionDecoder","getDiscriminatedUnionCodec","discriminatorValue","findIndex","key","getDataEnumEncoder","getDataEnumDecoder","getDataEnumCodec","getEnumStats","constructor","numericalValues","Set","Object","filter","v","sort","enumRecord","fromEntries","entries","enumKeys","keys","enumValues","stringValues","getEnumIndexFromVariant","valueIndex","findLastIndex","getEnumIndexFromDiscriminator","useValuesAsDiscriminators","predicate","l","formatNumericalValues","range","ranges","join","getEnumEncoder","some","formattedNumericalValues","getEnumDecoder","validDiscriminators","Array","formattedValidDiscriminators","getEnumCodec","getScalarEnumEncoder","getScalarEnumDecoder","getScalarEnumCodec","getHiddenPrefixEncoder","encoder","prefixedEncoders","getHiddenPrefixDecoder","decoder","prefixedDecoders","tuple","getHiddenPrefixCodec","prefixedCodecs","getHiddenSuffixEncoder","suffixedEncoders","getHiddenSuffixDecoder","suffixedDecoders","getHiddenSuffixCodec","suffixedCodecs","getMapEncoder","getMapDecoder","Map","getMapCodec","getUnitEncoder","_value","_bytes","getUnitDecoder","getUnitCodec","getNullableEncoder","_boolean","noneValue","assertIsFixedSize","fixEncoderSize","getNullableDecoder","fixDecoderSize","zeroValue","Uint8Array","fill","getNullableCodec","getSetEncoder","getSetDecoder","getStructEncoder","fields","fieldCodecs","struct","getStructDecoder","getSetCodec","getStructCodec"],"sources":["/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/array.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/assertions.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/utils.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/bit-array.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/boolean.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/bytes.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/constant.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/assertions.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/base16.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/base64.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/discriminated-union.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/tuple.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/union.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/enum.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/enum-helpers.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/hidden-prefix.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/hidden-suffix.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/map.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/nullable.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/unit.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/set.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-data-structures/src/struct.ts"],"sourcesContent":["import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Represents all the size options for array-like codecs\n * — i.e. `array`, `map` and `set`.\n *\n * It can be one of the following:\n * - a {@link NumberCodec} that prefixes its content with its size.\n * - a fixed number of items.\n * - or `'remainder'` to infer the number of items by dividing\n *   the rest of the byte array by the fixed size of its item.\n *   Note that this option is only available for fixed-size items.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/** Defines the configs for array codecs. */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Decodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an array of items.\n *\n * @param item - The codec to use for the array's items.\n * @param config - A set of config for the codec.\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type — i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/** Defines the config for bitArray codecs. */\nexport type BitArrayCodecConfig = {\n    /**\n     * Whether to read the bits in reverse order.\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Encodes an array of booleans into bits.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the encoder.\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Decodes bits into an array of booleans.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the decoder.\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * An array of boolean codec that converts booleans to bits and vice versa.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the codec.\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/** Defines the config for boolean codecs. */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec to delegate to.\n     * @defaultValue u8 size.\n     */\n    size?: TSize;\n};\n\n/**\n * Encodes booleans.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Decodes booleans.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Creates a boolean codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Encodes byte arrays as provided.\n *\n * To control the size of the encoded byte array, you can use\n * the `fixEncoderSize` or `addEncoderSizePrefix` functions.\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Decodes byte arrays as-is.\n *\n * To control the size of the decoded byte array, you can use\n * the `fixDecoderSize` or `addDecoderSizePrefix` functions.\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Creates a sized bytes codec.\n *\n * To control the size of the encoded and decoded byte arrays,\n * you can use the `fixCodecSize` or `addCodecSizePrefix` functions.\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Creates a void encoder that always sets the provided byte array when encoding.\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Creates a void decoder that reads the next bytes and fails if they do not match the provided constant.\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Creates a void codec that always sets the provided byte array\n * when encoding and, when decoding, asserts that the next\n * bytes match the provided byte array.\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Codec, combineCodec, Decoder, Encoder, transformDecoder, transformEncoder } from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Defines a discriminated union using discriminated union types.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariant<WebPageEvent, '__kind', 'click'>;\n * // -> { __kind: 'click', x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariantContent<WebPageEvent, '__kind', 'click'>;\n * // -> { x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/** Defines the config for discriminated union codecs. */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`.\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec to use for the enum discriminator prefixing the variant.\n     * @defaultValue u8 prefix.\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\n/**\n * Creates a discriminated union encoder.\n *\n * @param variants - The variant encoders of the discriminated union.\n * @param config - A set of config for the encoder.\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    );\n}\n\n/**\n * Creates a discriminated union decoder.\n *\n * @param variants - The variant decoders of the discriminated union.\n * @param config - A set of config for the decoder.\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    );\n}\n\n/**\n * Creates a discriminated union codec.\n *\n * @param variants - The variant codecs of the discriminated union.\n * @param config - A set of config for the codec.\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n    GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n        GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config),\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    );\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n\n/** @deprecated Use `getDiscriminatedUnionEncoder` instead. */\nexport const getDataEnumEncoder = getDiscriminatedUnionEncoder;\n\n/** @deprecated Use `getDiscriminatedUnionDecoder` instead. */\nexport const getDataEnumDecoder = getDiscriminatedUnionDecoder;\n\n/** @deprecated Use `getDiscriminatedUnionCodec` instead. */\nexport const getDataEnumCodec = getDiscriminatedUnionCodec;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a tuple-like array.\n *\n * @param items - The encoders to use for each item in the tuple.\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a tuple-like array.\n *\n * @param items - The decoders to use for each item in the tuple.\n */\n\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a tuple-like array.\n *\n * @param items - The codecs to use for each item in the tuple.\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Creates a union encoder from the provided array of encoder.\n *\n * @param variants - The variant encoders of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    });\n}\n\n/**\n * Creates a union decoder from the provided array of decoder.\n *\n * @param variants - The variant decoders of the union.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Creates a union codec from the provided array of codec.\n *\n * @param variants - The variant codecs of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants, getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/** Defines the config for enum codecs. */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator.\n     * @defaultValue u8 discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * When set to `true`, numeric values will be used as discriminantors and\n     * an error will be thrown if a string value is found on the enum.\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Creates an enum encoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the encoder.\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Creates an enum decoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the decoder.\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Creates an enum codec.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the codec.\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n\n/** @deprecated Use `getEnumEncoder` instead. */\nexport const getScalarEnumEncoder = getEnumEncoder;\n\n/** @deprecated Use `getEnumDecoder` instead. */\nexport const getScalarEnumDecoder = getEnumDecoder;\n\n/** @deprecated Use `getEnumCodec` instead. */\nexport const getScalarEnumCodec = getEnumCodec;\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [\n        ...new Set(Object.values(constructor).filter(v => typeof v === 'number') as number[]),\n    ].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Prefixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Prefixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Prefixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Suffixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Suffixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Suffixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/** Defines the config for Map codecs. */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Creates a encoder for a map.\n *\n * @param key - The encoder to use for the map's keys.\n * @param value - The encoder to use for the map's values.\n * @param config - A set of config for the encoder.\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Creates a decoder for a map.\n *\n * @param key - The decoder to use for the map's keys.\n * @param value - The decoder to use for the map's values.\n * @param config - A set of config for the decoder.\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Creates a codec for a map.\n *\n * @param key - The codec to use for the map's keys.\n * @param value - The codec to use for the map's values.\n * @param config - A set of config for the codec.\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/** Defines the config for nullable codecs. */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Defines how the `None` (or `null`) value should be represented.\n     *\n     * By default, no none value is used. This means a `null` value will be\n     * represented by the absence of the item.\n     *\n     * When `'zeroes'` is provided, a `null` value will skip the bytes that would\n     * have been used for the item. Note that this returns a fixed-size codec\n     * and thus will only work if the item codec is of fixed size.\n     *\n     * When a custom byte array is provided, a `null` value will be represented\n     * by the provided byte array. Note that this returns a variable-size codec\n     * since the byte array representing `null` does not need to match the size\n     * of the item codec.\n     *\n     * @defaultValue No none value is used.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The codec to use for the boolean prefix, if any.\n     *\n     * By default a `u8` number is used as a prefix to determine if the value is `null`.\n     * The value `0` is encoded for `null` and `1` if the value is present.\n     * This can be set to any number codec to customize the prefix.\n     *\n     * When `null` is provided, no prefix is used and the `noneValue` is used to\n     * determine if the value is `null`. If no `noneValue` is provided, then the\n     * absence of any bytes is used to determine if the value is `null`.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Creates a void encoder.\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Creates a void decoder.\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Creates a void codec.\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/** Defines the config for set codecs. */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the set.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Decodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Creates a codec for an set of items.\n *\n * @param item - The codec to use for the set's items.\n * @param config - A set of config for the codec.\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype Fields<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a custom object.\n *\n * @param fields - The name and encoder of each field.\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a custom object.\n *\n * @param fields - The name and decoder of each field.\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a custom object.\n *\n * @param fields - The name and codec of each field.\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
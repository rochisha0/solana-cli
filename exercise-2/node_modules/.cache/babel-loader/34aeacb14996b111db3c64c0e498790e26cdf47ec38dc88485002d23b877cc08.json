{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES } from '@solana/errors';\n\n// src/add-codec-sentinel.ts\n\n// src/bytes.ts\nvar mergeBytes = byteArrays => {\n  const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n  if (nonEmptyByteArrays.length === 0) {\n    return byteArrays.length ? byteArrays[0] : new Uint8Array();\n  }\n  if (nonEmptyByteArrays.length === 1) {\n    return nonEmptyByteArrays[0];\n  }\n  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  nonEmptyByteArrays.forEach(arr => {\n    result.set(arr, offset);\n    offset += arr.length;\n  });\n  return result;\n};\nvar padBytes = (bytes, length) => {\n  if (bytes.length >= length) return bytes;\n  const paddedBytes = new Uint8Array(length).fill(0);\n  paddedBytes.set(bytes);\n  return paddedBytes;\n};\nvar fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n  const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n  if (slice.length !== bytes.length) return false;\n  return bytes.every((b, i) => b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n  return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n  return Object.freeze({\n    ...encoder,\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, encoder));\n      encoder.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction createDecoder(decoder) {\n  return Object.freeze({\n    ...decoder,\n    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]\n  });\n}\nfunction createCodec(codec) {\n  return Object.freeze({\n    ...codec,\n    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, codec));\n      codec.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction isFixedSize(codec) {\n  return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n  if (!isFixedSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n  }\n}\nfunction isVariableSize(codec) {\n  return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n  if (!isVariableSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n  }\n}\nfunction combineCodec(encoder, decoder) {\n  if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n  }\n  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n      decoderFixedSize: decoder.fixedSize,\n      encoderFixedSize: encoder.fixedSize\n    });\n  }\n  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n      decoderMaxSize: decoder.maxSize,\n      encoderMaxSize: encoder.maxSize\n    });\n  }\n  return {\n    ...decoder,\n    ...encoder,\n    decode: decoder.decode,\n    encode: encoder.encode,\n    read: decoder.read,\n    write: encoder.write\n  };\n}\n\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n        encodedBytes: encoderBytes,\n        hexEncodedBytes: hexBytes(encoderBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    bytes.set(encoderBytes, offset);\n    offset += encoderBytes.length;\n    bytes.set(sentinel, offset);\n    offset += sentinel.length;\n    return offset;\n  };\n  if (isFixedSize(encoder)) {\n    return createEncoder({\n      ...encoder,\n      fixedSize: encoder.fixedSize + sentinel.length,\n      write\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    ...(encoder.maxSize != null ? {\n      maxSize: encoder.maxSize + sentinel.length\n    } : {}),\n    getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n    write\n  });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n  const read = (bytes, offset) => {\n    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n    if (sentinelIndex === -1) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n        decodedBytes: candidateBytes,\n        hexDecodedBytes: hexBytes(candidateBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n  };\n  if (isFixedSize(decoder)) {\n    return createDecoder({\n      ...decoder,\n      fixedSize: decoder.fixedSize + sentinel.length,\n      read\n    });\n  }\n  return createDecoder({\n    ...decoder,\n    ...(decoder.maxSize != null ? {\n      maxSize: decoder.maxSize + sentinel.length\n    } : {}),\n    read\n  });\n}\nfunction addCodecSentinel(codec, sentinel) {\n  return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n  return bytes.findIndex((byte, index, arr) => {\n    if (sentinel.length === 1) return byte === sentinel[0];\n    return containsBytes(arr, sentinel, index);\n  });\n}\nfunction hexBytes(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n  if (bytes.length - offset <= 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n      codecDescription\n    });\n  }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n  const bytesLength = bytes.length - offset;\n  if (bytesLength < expected) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n      bytesLength,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n  if (offset < 0 || offset > bytesLength) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n      bytesLength,\n      codecDescription,\n      offset\n    });\n  }\n}\n\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    offset = prefix.write(encoderBytes.length, bytes, offset);\n    bytes.set(encoderBytes, offset);\n    return offset + encoderBytes.length;\n  };\n  if (isFixedSize(prefix) && isFixedSize(encoder)) {\n    return createEncoder({\n      ...encoder,\n      fixedSize: prefix.fixedSize + encoder.fixedSize,\n      write\n    });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n  return createEncoder({\n    ...encoder,\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    getSizeFromValue: value => {\n      const encoderSize = getEncodedSize(value, encoder);\n      return getEncodedSize(encoderSize, prefix) + encoderSize;\n    },\n    write\n  });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n  const read = (bytes, offset) => {\n    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n    const size = Number(bigintSize);\n    offset = decoderOffset;\n    if (offset > 0 || bytes.length > size) {\n      bytes = bytes.slice(offset, offset + size);\n    }\n    assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n    return [decoder.decode(bytes), offset + size];\n  };\n  if (isFixedSize(prefix) && isFixedSize(decoder)) {\n    return createDecoder({\n      ...decoder,\n      fixedSize: prefix.fixedSize + decoder.fixedSize,\n      read\n    });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n  return createDecoder({\n    ...decoder,\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    read\n  });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n  return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n  return createEncoder({\n    fixedSize: fixedBytes,\n    write: (value, bytes, offset) => {\n      const variableByteArray = encoder.encode(value);\n      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n      bytes.set(fixedByteArray, offset);\n      return offset + fixedBytes;\n    }\n  });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n  return createDecoder({\n    fixedSize: fixedBytes,\n    read: (bytes, offset) => {\n      assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n      if (offset > 0 || bytes.length > fixedBytes) {\n        bytes = bytes.slice(offset, offset + fixedBytes);\n      }\n      if (isFixedSize(decoder)) {\n        bytes = fixBytes(bytes, decoder.fixedSize);\n      }\n      const [value] = decoder.read(bytes, 0);\n      return [value, offset + fixedBytes];\n    }\n  });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n  return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n      const postOffset = encoder.write(value, bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n      return newPostOffset;\n    }\n  });\n}\nfunction offsetDecoder(decoder, config) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n      const [value, postOffset] = decoder.read(bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n      return [value, newPostOffset];\n    }\n  });\n}\nfunction offsetCodec(codec, config) {\n  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n  if (divisor === 0) return 0;\n  return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n  if (isFixedSize(encoder)) {\n    const fixedSize = resize(encoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeEncoder\"\n      });\n    }\n    return createEncoder({\n      ...encoder,\n      fixedSize\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    getSizeFromValue: value => {\n      const newSize = resize(encoder.getSizeFromValue(value));\n      if (newSize < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n          bytesLength: newSize,\n          codecDescription: \"resizeEncoder\"\n        });\n      }\n      return newSize;\n    }\n  });\n}\nfunction resizeDecoder(decoder, resize) {\n  if (isFixedSize(decoder)) {\n    const fixedSize = resize(decoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeDecoder\"\n      });\n    }\n    return createDecoder({\n      ...decoder,\n      fixedSize\n    });\n  }\n  return decoder;\n}\nfunction resizeCodec(codec, resize) {\n  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    preOffset: ({\n      preOffset\n    }) => preOffset + offset\n  });\n}\nfunction padRightEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    postOffset: ({\n      postOffset\n    }) => postOffset + offset\n  });\n}\nfunction padLeftDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    preOffset: ({\n      preOffset\n    }) => preOffset + offset\n  });\n}\nfunction padRightDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    postOffset: ({\n      postOffset\n    }) => postOffset + offset\n  });\n}\nfunction padLeftCodec(codec, offset) {\n  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n  while (sourceOffset < --sourceLength) {\n    const leftValue = source[sourceOffset];\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n    sourceOffset++;\n  }\n  if (sourceOffset === sourceLength) {\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n  }\n}\nfunction reverseEncoder(encoder) {\n  assertIsFixedSize(encoder);\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, offset) => {\n      const newOffset = encoder.write(value, bytes, offset);\n      copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n      return newOffset;\n    }\n  });\n}\nfunction reverseDecoder(decoder) {\n  assertIsFixedSize(decoder);\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const reversedBytes = bytes.slice();\n      copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n      return decoder.read(reversedBytes, offset);\n    }\n  });\n}\nfunction reverseCodec(codec) {\n  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n  return createEncoder({\n    ...(isVariableSize(encoder) ? {\n      ...encoder,\n      getSizeFromValue: value => encoder.getSizeFromValue(unmap(value))\n    } : encoder),\n    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)\n  });\n}\nfunction transformDecoder(decoder, map) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      return [map(value, bytes, offset), newOffset];\n    }\n  });\n}\nfunction transformCodec(codec, unmap, map) {\n  return createCodec({\n    ...transformEncoder(codec, unmap),\n    read: map ? transformDecoder(codec, map).read : codec.read\n  });\n}\nexport { addCodecSentinel, addCodecSizePrefix, addDecoderSentinel, addDecoderSizePrefix, addEncoderSentinel, addEncoderSizePrefix, assertByteArrayHasEnoughBytesForCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayOffsetIsNotOutOfRange, assertIsFixedSize, assertIsVariableSize, combineCodec, containsBytes, createCodec, createDecoder, createEncoder, fixBytes, fixCodecSize, fixDecoderSize, fixEncoderSize, getEncodedSize, isFixedSize, isVariableSize, mergeBytes, offsetCodec, offsetDecoder, offsetEncoder, padBytes, padLeftCodec, padLeftDecoder, padLeftEncoder, padRightCodec, padRightDecoder, padRightEncoder, resizeCodec, resizeDecoder, resizeEncoder, reverseCodec, reverseDecoder, reverseEncoder, transformCodec, transformDecoder, transformEncoder };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["mergeBytes","byteArrays","length","Uint8Array","nonEmptyByteArrays","totalLength","reduce","total","arr","result","offset","forEach","set","padBytes","bytes","paddedBytes","fill","fixBytes","slice","containsBytes","data","every","b","i","getEncodedSize","value","encoder","fixedSize","getSizeFromValue","encode","write","createDecoder","decoder","Object","freeze","decode","read","createCodec","codec","isFixedSize","assertIsFixedSize","SolanaError","SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH","isVariableSize","assertIsVariableSize","SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH","combineCodec","SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH","SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH","decoderFixedSize","encoderFixedSize","decoderMaxSize","maxSize","encoderMaxSize","addEncoderSentinel","sentinel","encoderBytes","findSentinelIndex","SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL","encodedBytes","hexEncodedBytes","hexBytes","hexSentinel","createEncoder","addDecoderSentinel","candidateBytes","sentinelIndex","SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES","decodedBytes","hexDecodedBytes","preSentinelBytes","addCodecSentinel","findIndex","byte","index","str","toString","padStart","assertByteArrayIsNotEmptyForCodec","codecDescription","SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY","assertByteArrayHasEnoughBytesForCodec","expected","bytesLength","SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH","assertByteArrayOffsetIsNotOutOfRange","addEncoderSizePrefix","prefix","prefixMaxSize","encoderSize","addDecoderSizePrefix","size","Number","bigintSize","decoderOffset","addCodecSizePrefix","fixEncoderSize","fixedBytes","variableByteArray","fixedByteArray","fixDecoderSize","fixCodecSize","offsetEncoder","config","preOffset","wrapBytes","modulo","newPreOffset","postOffset","newPostOffset","offsetDecoder","offsetCodec","dividend","divisor","resizeEncoder","resize","SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH","newSize","resizeDecoder","resizeCodec","padLeftEncoder","padRightEncoder","padLeftDecoder","padRightDecoder","padLeftCodec","copySourceToTargetInReverse","source","target_WILL_MUTATE","sourceOffset","sourceLength","targetOffset","leftValue","reverseEncoder","newOffset","reversedBytes","reverseCodec","reverseDecoder","transformEncoder","unmap","transformDecoder","map","transformCodec","padRightCodec"],"sources":["/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/add-codec-sentinel.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/bytes.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/combine-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/assertions.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/add-codec-size-prefix.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/fix-codec-size.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/offset-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/resize-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/pad-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/reverse-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-core/src/transform-codec.ts"],"sourcesContent":["import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * Note that, if the sentinel is found in the encoded value, an error is thrown.\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until a `Uint8Array` sentinel is found.\n *\n * If the sentinel is not found in the byte array to decode, an error is thrown.\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * Note that, if the sentinel is found in the encoded value\n * or not found in the byte array to decode, an error is thrown.\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the `decoder` by reading the `prefix` encoder prefix.\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Bounds the size of the `codec` using the provided `prefix` codec prefix.\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder.\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder.\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec.\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n */\n\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder.\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder.\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder.\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder.\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec.\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec.\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
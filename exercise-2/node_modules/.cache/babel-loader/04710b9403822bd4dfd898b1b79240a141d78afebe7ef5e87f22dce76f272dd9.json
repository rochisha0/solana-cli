{"ast":null,"code":"import { isFixedSize, assertIsFixedSize, createEncoder, getEncodedSize, createDecoder, combineCodec } from '@solana/codecs-core';\nimport { getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\n\n// src/option.ts\nvar some = value => ({\n  __option: \"Some\",\n  value\n});\nvar none = () => ({\n  __option: \"None\"\n});\nvar isOption = input => !!(input && typeof input === \"object\" && \"__option\" in input && (input.__option === \"Some\" && \"value\" in input || input.__option === \"None\"));\nvar isSome = option => option.__option === \"Some\";\nvar isNone = option => option.__option === \"None\";\n\n// src/unwrap-option.ts\nfunction unwrapOption(option, fallback) {\n  if (isSome(option)) return option.value;\n  return fallback ? fallback() : null;\n}\nvar wrapNullable = nullable => nullable !== null ? some(nullable) : none();\n\n// src/option-codec.ts\nfunction getOptionEncoder(item, config = {}) {\n  const prefix = config.prefix ?? getU8Encoder();\n  const fixed = config.fixed ?? false;\n  const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n  if (fixed || isZeroSizeItem) {\n    assertIsFixedSize(item);\n    assertIsFixedSize(prefix);\n    const fixedSize = prefix.fixedSize + item.fixedSize;\n    return createEncoder({\n      fixedSize,\n      write: (optionOrNullable, bytes, offset) => {\n        const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n        const prefixOffset = prefix.write(Number(isSome(option)), bytes, offset);\n        if (isSome(option)) {\n          item.write(option.value, bytes, prefixOffset);\n        }\n        return offset + fixedSize;\n      }\n    });\n  }\n  return createEncoder({\n    getSizeFromValue: optionOrNullable => {\n      const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n      return getEncodedSize(Number(isSome(option)), prefix) + (isSome(option) ? getEncodedSize(option.value, item) : 0);\n    },\n    maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? void 0,\n    write: (optionOrNullable, bytes, offset) => {\n      const option = isOption(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n      offset = prefix.write(Number(isSome(option)), bytes, offset);\n      if (isSome(option)) {\n        offset = item.write(option.value, bytes, offset);\n      }\n      return offset;\n    }\n  });\n}\nfunction getOptionDecoder(item, config = {}) {\n  const prefix = config.prefix ?? getU8Decoder();\n  const fixed = config.fixed ?? false;\n  let fixedSize = null;\n  const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n  if (fixed || isZeroSizeItem) {\n    assertIsFixedSize(item);\n    assertIsFixedSize(prefix);\n    fixedSize = prefix.fixedSize + item.fixedSize;\n  }\n  return createDecoder({\n    ...(fixedSize === null ? {\n      maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? void 0\n    } : {\n      fixedSize\n    }),\n    read: (bytes, offset) => {\n      if (bytes.length - offset <= 0) {\n        return [none(), offset];\n      }\n      const [isSome2, prefixOffset] = prefix.read(bytes, offset);\n      if (isSome2 === 0) {\n        return [none(), fixedSize !== null ? offset + fixedSize : prefixOffset];\n      }\n      const [value, newOffset] = item.read(bytes, prefixOffset);\n      return [some(value), fixedSize !== null ? offset + fixedSize : newOffset];\n    }\n  });\n}\nfunction getOptionCodec(item, config = {}) {\n  return combineCodec(getOptionEncoder(item, config), getOptionDecoder(item, config));\n}\nfunction sumCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);\n}\nfunction getMaxSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n\n// src/unwrap-option-recursively.ts\nfunction unwrapOptionRecursively(input, fallback) {\n  if (!input || ArrayBuffer.isView(input)) {\n    return input;\n  }\n  const next = x => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);\n  if (isOption(input)) {\n    if (isSome(input)) return next(input.value);\n    return fallback ? fallback() : null;\n  }\n  if (Array.isArray(input)) {\n    return input.map(next);\n  }\n  if (typeof input === \"object\") {\n    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));\n  }\n  return input;\n}\nexport { getOptionCodec, getOptionDecoder, getOptionEncoder, isNone, isOption, isSome, none, some, unwrapOption, unwrapOptionRecursively, wrapNullable };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["getU8Encoder","getU8Decoder","some","value","__option","none","isNone","option","unwrapOption","fallback","isSome","wrapNullable","nullable","getOptionEncoder","item","config","isZeroSizeItem","isFixedSize","prefix","fixedSize","fixed","assertIsFixedSize","createEncoder","isOption","optionOrNullable","prefixOffset","write","Number","bytes","offset","getSizeFromValue","getEncodedSize","maxSize","sumCodecSizes","map","getMaxSize","getOptionDecoder","createDecoder","read","length","isSome2","newOffset","getOptionCodec","combineCodec","sizes","reduce","all","size","codec","unwrapOptionRecursively","input","ArrayBuffer","isView","next","x","Object","fromEntries","entries","k","v"],"sources":["/home/rochisha/solana-token-ui/node_modules/@solana/options/src/option.ts","/home/rochisha/solana-token-ui/node_modules/@solana/options/src/option-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/options/src/unwrap-option.ts","/home/rochisha/solana-token-ui/node_modules/@solana/options/src/unwrap-option-recursively.ts"],"sourcesContent":["/**\n * An implementation of the Rust Option type in JavaScript.\n * It can be one of the following:\n * - <code>{@link Some}<T></code>: Meaning there is a value of type T.\n * - <code>{@link None}</code>: Meaning there is no value.\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * Defines a looser type that can be used when serializing an {@link Option}.\n * This allows us to pass null or the Option value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an option of type `T` that has a value.\n *\n * @see {@link Option}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an option of type `T` that has no value.\n *\n * @see {@link Option}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} of type `T` that has a value.\n *\n * @see {@link Option}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} of type `T` that has no value.\n *\n * @see {@link Option}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Whether the given data is an {@link Option}.\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Whether the given {@link Option} is a {@link Some}.\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Whether the given {@link Option} is a {@link None}.\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, none, Option, OptionOrNullable, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/** Defines the config for option codecs. */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Whether the item codec should be of fixed size.\n     *\n     * When this is true, a `None` value will skip the bytes that would\n     * have been used for the item. Note that this will only work if the\n     * item codec is of fixed size.\n     * @defaultValue `false`\n     */\n    fixed?: boolean;\n\n    /**\n     * The codec to use for the boolean prefix.\n     * @defaultValue u8 prefix.\n     */\n    prefix?: TPrefix;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { fixed: true },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom, 0>,\n    config?: OptionCodecConfig<FixedSizeNumberEncoder>,\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { fixed?: false },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = config.prefix ?? getU8Encoder();\n    const fixed = config.fixed ?? false;\n\n    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n    if (fixed || isZeroSizeItem) {\n        assertIsFixedSize(item);\n        assertIsFixedSize(prefix);\n        const fixedSize = prefix.fixedSize + item.fixedSize;\n        return createEncoder({\n            fixedSize,\n            write: (optionOrNullable: OptionOrNullable<TFrom>, bytes, offset) => {\n                const option = isOption<TFrom>(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n                const prefixOffset = prefix.write(Number(isSome(option)), bytes, offset);\n                if (isSome(option)) {\n                    item.write(option.value, bytes, prefixOffset);\n                }\n                return offset + fixedSize;\n            },\n        });\n    }\n\n    return createEncoder({\n        getSizeFromValue: (optionOrNullable: OptionOrNullable<TFrom>) => {\n            const option = isOption<TFrom>(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n            return (\n                getEncodedSize(Number(isSome(option)), prefix) +\n                (isSome(option) ? getEncodedSize(option.value, item) : 0)\n            );\n        },\n        maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? undefined,\n        write: (optionOrNullable: OptionOrNullable<TFrom>, bytes, offset) => {\n            const option = isOption<TFrom>(optionOrNullable) ? optionOrNullable : wrapNullable(optionOrNullable);\n            offset = prefix.write(Number(isSome(option)), bytes, offset);\n            if (isSome(option)) {\n                offset = item.write(option.value, bytes, offset);\n            }\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { fixed: true },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo, 0>,\n    config?: OptionCodecConfig<FixedSizeNumberDecoder>,\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { fixed?: false },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = config.prefix ?? getU8Decoder();\n    const fixed = config.fixed ?? false;\n\n    let fixedSize: number | null = null;\n    const isZeroSizeItem = isFixedSize(item) && isFixedSize(prefix) && item.fixedSize === 0;\n    if (fixed || isZeroSizeItem) {\n        assertIsFixedSize(item);\n        assertIsFixedSize(prefix);\n        fixedSize = prefix.fixedSize + item.fixedSize;\n    }\n\n    return createDecoder({\n        ...(fixedSize === null\n            ? { maxSize: sumCodecSizes([prefix, item].map(getMaxSize)) ?? undefined }\n            : { fixedSize }),\n        read: (bytes: Uint8Array, offset) => {\n            if (bytes.length - offset <= 0) {\n                return [none(), offset];\n            }\n            const [isSome, prefixOffset] = prefix.read(bytes, offset);\n            if (isSome === 0) {\n                return [none(), fixedSize !== null ? offset + fixedSize : prefixOffset];\n            }\n            const [value, newOffset] = item.read(bytes, prefixOffset);\n            return [some(value), fixedSize !== null ? offset + fixedSize : newOffset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { fixed: true },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo, 0>,\n    config?: OptionCodecConfig<FixedSizeNumberCodec>,\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { fixed?: false },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    return combineCodec(getOptionEncoder<TFrom>(item, config as object), getOptionDecoder<TTo>(item, config as object));\n}\n\nfunction sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nfunction getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option} of type `T`\n * or returns a fallback value that defaults to `null`.\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Lists all types that should not be recursively unwrapped.\n *\n * @see {@link UnwrappedOption}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that defines the recursive unwrapping of a type `T`\n * such that all nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns the type of its value, otherwise, it returns the provided\n * fallback type `U` which defaults to `null`.\n */\nexport type UnwrappedOption<T, U = null> = T extends Some<infer TValue>\n    ? UnwrappedOption<TValue, U>\n    : T extends None\n      ? U\n      : T extends UnUnwrappables\n        ? T\n        : T extends object\n          ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n          : T extends Array<infer TItem>\n            ? Array<UnwrappedOption<TItem, U>>\n            : T;\n\n/**\n * Recursively go through a type `T` such that all\n * nested {@link Option} types are unwrapped.\n *\n * For each nested {@link Option} type, if the option is a {@link Some},\n * it returns its value, otherwise, it returns the provided fallback value\n * which defaults to `null`.\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE } from '@solana/errors';\nimport { combineCodec, createEncoder, createDecoder, assertByteArrayIsNotEmptyForCodec, assertByteArrayHasEnoughBytesForCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n  if (value < min || value > max) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n      codecDescription,\n      max,\n      min,\n      value\n    });\n  }\n}\n\n// src/common.ts\nvar Endian = /* @__PURE__ */(Endian2 => {\n  Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n  Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n  return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n  return config?.endian === 1 /* Big */ ? false : true;\n}\nfunction numberEncoderFactory(input) {\n  return createEncoder({\n    fixedSize: input.size,\n    write(value, bytes, offset) {\n      if (input.range) {\n        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n      }\n      const arrayBuffer = new ArrayBuffer(input.size);\n      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n      bytes.set(new Uint8Array(arrayBuffer), offset);\n      return offset + input.size;\n    }\n  });\n}\nfunction numberDecoderFactory(input) {\n  return createDecoder({\n    fixedSize: input.size,\n    read(bytes, offset = 0) {\n      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n      const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n      return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n    }\n  });\n}\nfunction toArrayBuffer(bytes, offset, length) {\n  const bytesOffset = bytes.byteOffset + (offset ?? 0);\n  const bytesLength = length ?? bytes.byteLength;\n  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n\n// src/f32.ts\nvar getF32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"f32\",\n  set: (view, value, le) => view.setFloat32(0, value, le),\n  size: 4\n});\nvar getF32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getFloat32(0, le),\n  name: \"f32\",\n  size: 4\n});\nvar getF32Codec = (config = {}) => combineCodec(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"f64\",\n  set: (view, value, le) => view.setFloat64(0, value, le),\n  size: 8\n});\nvar getF64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getFloat64(0, le),\n  name: \"f64\",\n  size: 8\n});\nvar getF64Codec = (config = {}) => combineCodec(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i128\",\n  range: [-BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getI128Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigInt64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"i128\",\n  size: 16\n});\nvar getI128Codec = (config = {}) => combineCodec(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i16\",\n  range: [-Number(\"0x7fff\") - 1, Number(\"0x7fff\")],\n  set: (view, value, le) => view.setInt16(0, value, le),\n  size: 2\n});\nvar getI16Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getInt16(0, le),\n  name: \"i16\",\n  size: 2\n});\nvar getI16Codec = (config = {}) => combineCodec(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i32\",\n  range: [-Number(\"0x7fffffff\") - 1, Number(\"0x7fffffff\")],\n  set: (view, value, le) => view.setInt32(0, value, le),\n  size: 4\n});\nvar getI32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getInt32(0, le),\n  name: \"i32\",\n  size: 4\n});\nvar getI32Codec = (config = {}) => combineCodec(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i64\",\n  range: [-BigInt(\"0x7fffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffff\")],\n  set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n  size: 8\n});\nvar getI64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getBigInt64(0, le),\n  name: \"i64\",\n  size: 8\n});\nvar getI64Codec = (config = {}) => combineCodec(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = () => numberEncoderFactory({\n  name: \"i8\",\n  range: [-Number(\"0x7f\") - 1, Number(\"0x7f\")],\n  set: (view, value) => view.setInt8(0, value),\n  size: 1\n});\nvar getI8Decoder = () => numberDecoderFactory({\n  get: view => view.getInt8(0),\n  name: \"i8\",\n  size: 1\n});\nvar getI8Codec = () => combineCodec(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = () => createEncoder({\n  getSizeFromValue: value => {\n    if (value <= 127) return 1;\n    if (value <= 16383) return 2;\n    return 3;\n  },\n  maxSize: 3,\n  write: (value, bytes, offset) => {\n    assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n    const shortU16Bytes = [0];\n    for (let ii = 0;; ii += 1) {\n      const alignedValue = value >> ii * 7;\n      if (alignedValue === 0) {\n        break;\n      }\n      const nextSevenBits = 127 & alignedValue;\n      shortU16Bytes[ii] = nextSevenBits;\n      if (ii > 0) {\n        shortU16Bytes[ii - 1] |= 128;\n      }\n    }\n    bytes.set(shortU16Bytes, offset);\n    return offset + shortU16Bytes.length;\n  }\n});\nvar getShortU16Decoder = () => createDecoder({\n  maxSize: 3,\n  read: (bytes, offset) => {\n    let value = 0;\n    let byteCount = 0;\n    while (++byteCount) {\n      const byteIndex = byteCount - 1;\n      const currentByte = bytes[offset + byteIndex];\n      const nextSevenBits = 127 & currentByte;\n      value |= nextSevenBits << byteIndex * 7;\n      if ((currentByte & 128) === 0) {\n        break;\n      }\n    }\n    return [value, offset + byteCount];\n  }\n});\nvar getShortU16Codec = () => combineCodec(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u128\",\n  range: [0n, BigInt(\"0xffffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getU128Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigUint64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"u128\",\n  size: 16\n});\nvar getU128Codec = (config = {}) => combineCodec(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u16\",\n  range: [0, Number(\"0xffff\")],\n  set: (view, value, le) => view.setUint16(0, value, le),\n  size: 2\n});\nvar getU16Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getUint16(0, le),\n  name: \"u16\",\n  size: 2\n});\nvar getU16Codec = (config = {}) => combineCodec(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u32\",\n  range: [0, Number(\"0xffffffff\")],\n  set: (view, value, le) => view.setUint32(0, value, le),\n  size: 4\n});\nvar getU32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getUint32(0, le),\n  name: \"u32\",\n  size: 4\n});\nvar getU32Codec = (config = {}) => combineCodec(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u64\",\n  range: [0n, BigInt(\"0xffffffffffffffff\")],\n  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n  size: 8\n});\nvar getU64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getBigUint64(0, le),\n  name: \"u64\",\n  size: 8\n});\nvar getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = () => numberEncoderFactory({\n  name: \"u8\",\n  range: [0, Number(\"0xff\")],\n  set: (view, value) => view.setUint8(0, value),\n  size: 1\n});\nvar getU8Decoder = () => numberDecoderFactory({\n  get: view => view.getUint8(0),\n  name: \"u8\",\n  size: 1\n});\nvar getU8Codec = () => combineCodec(getU8Encoder(), getU8Decoder());\nexport { Endian, assertNumberIsBetweenForCodec, getF32Codec, getF32Decoder, getF32Encoder, getF64Codec, getF64Decoder, getF64Encoder, getI128Codec, getI128Decoder, getI128Encoder, getI16Codec, getI16Decoder, getI16Encoder, getI32Codec, getI32Decoder, getI32Encoder, getI64Codec, getI64Decoder, getI64Encoder, getI8Codec, getI8Decoder, getI8Encoder, getShortU16Codec, getShortU16Decoder, getShortU16Encoder, getU128Codec, getU128Decoder, getU128Encoder, getU16Codec, getU16Decoder, getU16Encoder, getU32Codec, getU32Decoder, getU32Encoder, getU64Codec, getU64Decoder, getU64Encoder, getU8Codec, getU8Decoder, getU8Encoder };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["combineCodec","createEncoder","createDecoder","assertByteArrayIsNotEmptyForCodec","assertByteArrayHasEnoughBytesForCodec","assertNumberIsBetweenForCodec","codecDescription","min","max","value","SolanaError","SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE","Endian","Endian2","isLittleEndian","config","numberEncoderFactory","input","fixedSize","size","write","bytes","offset","range","name","arrayBuffer","ArrayBuffer","set","DataView","Uint8Array","numberDecoderFactory","read","view","toArrayBuffer","get","length","bytesOffset","byteOffset","bytesLength","byteLength","buffer","slice","getF32Encoder","le","setFloat32","getF32Decoder","getF32Codec","getF64Encoder","setFloat64","getF64Decoder","getFloat64","getF64Codec","getI128Encoder","BigInt","leftOffset","rightOffset","rightMask","setBigInt64","setBigUint64","left","getBigInt64","right","getBigUint64","getI128Codec","getI128Decoder","getI16Encoder","Number","setInt16","getI16Decoder","getInt16","getI16Codec","getI32Encoder","setInt32","getI32Decoder","getInt32","getI32Codec","getI64Encoder","getI64Decoder","getI64Codec","getI8Encoder","setInt8","getI8Decoder","getI8Codec","getShortU16Encoder","getSizeFromValue","maxSize","shortU16Bytes","ii","alignedValue","nextSevenBits","getShortU16Decoder","byteCount","byteIndex","currentByte","getShortU16Codec","getU128Encoder","getU128Decoder","getU128Codec","getU16Encoder","setUint16","getU16Decoder","getU16Codec","getU32Encoder","setUint32","getU32Decoder","getUint32","getU32Codec","getU64Encoder","getU64Decoder","getU64Codec","getU8Encoder","setUint8","getU8Decoder","getUint8","getU8Codec"],"sources":["/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/assertions.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/common.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/f32.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/utils.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/f64.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/i128.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/i16.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/i32.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/i64.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/i8.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/short-u16.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/u128.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/u16.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/u32.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/u64.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-numbers/src/u8.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given number is between a given range.\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\n/** Defines a encoder for numbers and bigints. */\nexport type NumberEncoder = Encoder<bigint | number> | Encoder<number>;\n\n/** Defines a fixed-size encoder for numbers and bigints. */\nexport type FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\n\n/** Defines a decoder for numbers and bigints. */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/** Defines a fixed-size decoder for numbers and bigints. */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/** Defines a codec for numbers and bigints. */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\n\n/** Defines a fixed-size codec for numbers and bigints. */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/** Defines the config for number codecs that use more than one byte. */\nexport type NumberCodecConfig = {\n    /**\n     * Whether the serializer should use little-endian or big-endian encoding.\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/** Defines the endianness of a number serializer. */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, value, le),\n        size: 4,\n    });\n\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, value, le),\n        size: 8,\n    });\n\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, value, le),\n        size: 2,\n    });\n\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, value, le),\n        size: 4,\n    });\n\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI8Encoder = (): FixedSizeEncoder<number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, value),\n        size: 1,\n    });\n\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\nexport const getI8Codec = (): FixedSizeCodec<number, number, 1> => combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Encodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<number> =>\n    createEncoder({\n        getSizeFromValue: (value: number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = value >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Decodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Encodes and decodes short u16 numbers.\n *\n * Short u16 numbers are the same as u16, but serialized with 1 to 3 bytes.\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n */\nexport const getShortU16Codec = (): VariableSizeCodec<number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, value, le),\n        size: 2,\n    });\n\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, value, le),\n        size: 4,\n    });\n\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU8Encoder = (): FixedSizeEncoder<number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, value),\n        size: 1,\n    });\n\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\nexport const getU8Codec = (): FixedSizeCodec<number, number, 1> => combineCodec(getU8Encoder(), getU8Decoder());\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE } from '@solana/errors';\nimport { createEncoder, createDecoder, combineCodec, fixEncoder, getEncodedSize, fixDecoder, assertByteArrayIsNotEmptyForCodec, assertByteArrayHasEnoughBytesForCodec } from '@solana/codecs-core';\nimport { getU32Encoder, getU32Decoder } from '@solana/codecs-numbers';\n\n// src/assertions.ts\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n      alphabet: alphabet4,\n      base: alphabet4.length,\n      value: givenValue\n    });\n  }\n}\nvar getBaseXEncoder = alphabet4 => {\n  return createEncoder({\n    getSizeFromValue: value => {\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) return value.length;\n      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n    },\n    write(value, bytes, offset) {\n      assertValidBaseString(alphabet4, value);\n      if (value === \"\") return offset;\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) {\n        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n        return offset + leadingZeroes.length;\n      }\n      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      const tailBytes = [];\n      while (base10Number > 0n) {\n        tailBytes.unshift(Number(base10Number % 256n));\n        base10Number /= 256n;\n      }\n      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getBaseXDecoder = alphabet4 => {\n  return createDecoder({\n    read(rawBytes, offset) {\n      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n      if (bytes.length === 0) return [\"\", 0];\n      let trailIndex = bytes.findIndex(n => n !== 0);\n      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n      const leadingZeroes = alphabet4[0].repeat(trailIndex);\n      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n      return [leadingZeroes + tailChars, rawBytes.length];\n    }\n  });\n};\nvar getBaseXCodec = alphabet4 => combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n  return [leadingZeros, tailChars];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  let sum = 0n;\n  for (const char of value) {\n    sum *= base;\n    sum += BigInt(alphabet4.indexOf(char));\n  }\n  return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  const tailChars = [];\n  while (value > 0n) {\n    tailChars.unshift(alphabet4[Number(value % base)]);\n    value /= base;\n  }\n  return tailChars.join(\"\");\n}\n\n// src/base10.ts\nvar alphabet = \"0123456789\";\nvar getBase10Encoder = () => getBaseXEncoder(alphabet);\nvar getBase10Decoder = () => getBaseXDecoder(alphabet);\nvar getBase10Codec = () => getBaseXCodec(alphabet);\nvar getBase16Encoder = () => createEncoder({\n  getSizeFromValue: value => Math.ceil(value.length / 2),\n  write(value, bytes, offset) {\n    const lowercaseValue = value.toLowerCase();\n    assertValidBaseString(\"0123456789abcdef\", lowercaseValue, value);\n    const matches = lowercaseValue.match(/.{1,2}/g);\n    const hexBytes = matches ? matches.map(byte => parseInt(byte, 16)) : [];\n    bytes.set(hexBytes, offset);\n    return hexBytes.length + offset;\n  }\n});\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nvar getBase16Codec = () => combineCodec(getBase16Encoder(), getBase16Decoder());\n\n// src/base58.ts\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = () => getBaseXEncoder(alphabet2);\nvar getBase58Decoder = () => getBaseXDecoder(alphabet2);\nvar getBase58Codec = () => getBaseXCodec(alphabet2);\nvar getBaseXResliceEncoder = (alphabet4, bits) => createEncoder({\n  getSizeFromValue: value => Math.floor(value.length * bits / 8),\n  write(value, bytes, offset) {\n    assertValidBaseString(alphabet4, value);\n    if (value === \"\") return offset;\n    const charIndices = [...value].map(c => alphabet4.indexOf(c));\n    const reslicedBytes = reslice(charIndices, bits, 8, false);\n    bytes.set(reslicedBytes, offset);\n    return reslicedBytes.length + offset;\n  }\n});\nvar getBaseXResliceDecoder = (alphabet4, bits) => createDecoder({\n  read(rawBytes, offset = 0) {\n    const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n    if (bytes.length === 0) return [\"\", rawBytes.length];\n    const charIndices = reslice([...bytes], 8, bits, true);\n    return [charIndices.map(i => alphabet4[i]).join(\"\"), rawBytes.length];\n  }\n});\nvar getBaseXResliceCodec = (alphabet4, bits) => combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));\nfunction reslice(input, inputBits, outputBits, useRemainder) {\n  const output = [];\n  let accumulator = 0;\n  let bitsInAccumulator = 0;\n  const mask = (1 << outputBits) - 1;\n  for (const value of input) {\n    accumulator = accumulator << inputBits | value;\n    bitsInAccumulator += inputBits;\n    while (bitsInAccumulator >= outputBits) {\n      bitsInAccumulator -= outputBits;\n      output.push(accumulator >> bitsInAccumulator & mask);\n    }\n  }\n  if (useRemainder && bitsInAccumulator > 0) {\n    output.push(accumulator << outputBits - bitsInAccumulator & mask);\n  }\n  return output;\n}\n\n// src/base64.ts\nvar alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar getBase64Encoder = () => {\n  {\n    return createEncoder({\n      getSizeFromValue: value => {\n        try {\n          return atob(value).length;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      },\n      write(value, bytes, offset) {\n        try {\n          const bytesToAdd = atob(value).split(\"\").map(c => c.charCodeAt(0));\n          bytes.set(bytesToAdd, offset);\n          return bytesToAdd.length + offset;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      }\n    });\n  }\n};\nvar getBase64Decoder = () => {\n  {\n    return createDecoder({\n      read(bytes, offset = 0) {\n        const slice = bytes.slice(offset);\n        const value = btoa(String.fromCharCode(...slice));\n        return [value, bytes.length];\n      }\n    });\n  }\n};\nvar getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder());\n\n// src/null-characters.ts\nvar removeNullCharacters = value =>\n// eslint-disable-next-line no-control-regex\nvalue.replace(/\\u0000/g, \"\");\nvar padNullCharacters = (value, chars) => value.padEnd(chars, \"\\0\");\n\n// ../text-encoding-impl/dist/index.browser.js\nvar e = globalThis.TextDecoder;\nvar o = globalThis.TextEncoder;\n\n// src/utf8.ts\nvar getUtf8Encoder = () => {\n  let textEncoder;\n  return createEncoder({\n    getSizeFromValue: value => (textEncoder ||= new o()).encode(value).length,\n    write: (value, bytes, offset) => {\n      const bytesToAdd = (textEncoder ||= new o()).encode(value);\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getUtf8Decoder = () => {\n  let textDecoder;\n  return createDecoder({\n    read(bytes, offset) {\n      const value = (textDecoder ||= new e()).decode(bytes.slice(offset));\n      return [removeNullCharacters(value), bytes.length];\n    }\n  });\n};\nvar getUtf8Codec = () => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n\n// src/string.ts\nfunction getStringEncoder(config = {}) {\n  const size = config.size ?? getU32Encoder();\n  const encoding = config.encoding ?? getUtf8Encoder();\n  if (size === \"variable\") {\n    return encoding;\n  }\n  if (typeof size === \"number\") {\n    return fixEncoder(encoding, size);\n  }\n  return createEncoder({\n    getSizeFromValue: value => {\n      const contentSize = getEncodedSize(value, encoding);\n      return getEncodedSize(contentSize, size) + contentSize;\n    },\n    write: (value, bytes, offset) => {\n      const contentSize = getEncodedSize(value, encoding);\n      offset = size.write(contentSize, bytes, offset);\n      return encoding.write(value, bytes, offset);\n    }\n  });\n}\nfunction getStringDecoder(config = {}) {\n  const size = config.size ?? getU32Decoder();\n  const encoding = config.encoding ?? getUtf8Decoder();\n  if (size === \"variable\") {\n    return encoding;\n  }\n  if (typeof size === \"number\") {\n    return fixDecoder(encoding, size);\n  }\n  return createDecoder({\n    read: (bytes, offset = 0) => {\n      assertByteArrayIsNotEmptyForCodec(\"string\", bytes, offset);\n      const [lengthBigInt, lengthOffset] = size.read(bytes, offset);\n      const length = Number(lengthBigInt);\n      offset = lengthOffset;\n      const contentBytes = bytes.slice(offset, offset + length);\n      assertByteArrayHasEnoughBytesForCodec(\"string\", length, contentBytes);\n      const [value, contentOffset] = encoding.read(contentBytes, 0);\n      offset += contentOffset;\n      return [value, offset];\n    }\n  });\n}\nfunction getStringCodec(config = {}) {\n  return combineCodec(getStringEncoder(config), getStringDecoder(config));\n}\nexport { assertValidBaseString, getBase10Codec, getBase10Decoder, getBase10Encoder, getBase16Codec, getBase16Decoder, getBase16Encoder, getBase58Codec, getBase58Decoder, getBase58Encoder, getBase64Codec, getBase64Decoder, getBase64Encoder, getBaseXCodec, getBaseXDecoder, getBaseXEncoder, getBaseXResliceCodec, getBaseXResliceDecoder, getBaseXResliceEncoder, getStringCodec, getStringDecoder, getStringEncoder, getUtf8Codec, getUtf8Decoder, getUtf8Encoder, padNullCharacters, removeNullCharacters };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["createEncoder","createDecoder","combineCodec","fixEncoder","getEncodedSize","fixDecoder","assertByteArrayIsNotEmptyForCodec","assertByteArrayHasEnoughBytesForCodec","getU32Encoder","getU32Decoder","assertValidBaseString","alphabet4","testValue","givenValue","match","RegExp","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","alphabet","base","length","value","getBaseXEncoder","getSizeFromValue","leadingZeroes","tailChars","partitionLeadingZeroes","base10Number","getBigIntFromBaseX","Math","ceil","toString","write","bytes","offset","set","Uint8Array","fill","tailBytes","unshift","Number","bytesToAdd","Array","getBaseXDecoder","read","rawBytes","slice","trailIndex","findIndex","n","repeat","reduce","sum","byte","BigInt","getBaseXFromBigInt","getBaseXCodec","zeroCharacter","leadingZeros","split","char","indexOf","join","getBase10Encoder","getBase16Encoder","lowercaseValue","toLowerCase","hexBytes","matches","map","parseInt","getBase16Decoder","str","padStart","getBase16Codec","alphabet2","getBase58Encoder","getBase58Decoder","getBase58Codec","getBaseXResliceEncoder","bits","floor","reslicedBytes","reslice","charIndices","i","output","accumulator","bitsInAccumulator","mask","outputBits","input","inputBits","push","useRemainder","alphabet3","getBase64Encoder","atob","e2","c","charCodeAt","getBase64Decoder","btoa","String","fromCharCode","getBase64Codec","removeNullCharacters","replace","padNullCharacters","chars","padEnd","e","globalThis","TextDecoder","o","TextEncoder","getUtf8Encoder","textEncoder","encode","getUtf8Decoder","textDecoder","decode","getUtf8Codec","getStringEncoder","config","size","encoding","contentSize","lengthOffset","contentBytes","contentOffset","getBase10Codec","getBase10Decoder","getBaseXResliceCodec","getBaseXResliceDecoder","getStringCodec","getStringDecoder"],"sources":["/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/assertions.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/baseX.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/base10.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/base16.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/base58.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/base64.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/baseX-reslice.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/null-characters.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/string.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-strings/src/utf8.ts","/home/rochisha/solana-token-ui/node_modules/@solana/text-encoding-impl/src/index.browser.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const lowercaseValue = value.toLowerCase();\n            assertValidBaseString('0123456789abcdef', lowercaseValue, value);\n            const matches = lowercaseValue.match(/.{1,2}/g);\n            const hexBytes = matches ? matches.map((byte: string) => parseInt(byte, 16)) : [];\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    mapDecoder,\n    mapEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return mapEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return mapDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    fixDecoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoder,\n    getEncodedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { getUtf8Decoder, getUtf8Encoder } from './utf8';\n\n/** Defines the config for string codecs. */\nexport type StringCodecConfig<\n    TPrefix extends NumberCodec | NumberDecoder | NumberEncoder,\n    TEncoding extends Codec<string> | Decoder<string> | Encoder<string>,\n> = {\n    /**\n     * The codec to use for encoding and decoding the content.\n     * @defaultValue UTF-8 encoding.\n     */\n    encoding?: TEncoding;\n\n    /**\n     * The size of the string. It can be one of the following:\n     * - a {@link NumberCodec} that prefixes the string with its size.\n     * - a fixed number of bytes.\n     * - or `'variable'` to use the rest of the byte array.\n     * @defaultValue u32 prefix.\n     */\n    size?: TPrefix | number | 'variable';\n};\n\n/** Encodes strings from a given encoding and size strategy. */\nexport function getStringEncoder<TSize extends number>(\n    config: StringCodecConfig<NumberEncoder, Encoder<string>> & { size: TSize },\n): FixedSizeEncoder<string, TSize>;\nexport function getStringEncoder<TSize extends number>(\n    config: StringCodecConfig<NumberEncoder, Encoder<string>> & {\n        encoding: FixedSizeEncoder<string, TSize>;\n        size: 'variable';\n    },\n): FixedSizeEncoder<string, TSize>;\nexport function getStringEncoder(\n    config?: StringCodecConfig<NumberEncoder, Encoder<string>>,\n): VariableSizeEncoder<string>;\nexport function getStringEncoder(config: StringCodecConfig<NumberEncoder, Encoder<string>> = {}): Encoder<string> {\n    const size = config.size ?? getU32Encoder();\n    const encoding = config.encoding ?? getUtf8Encoder();\n\n    if (size === 'variable') {\n        return encoding;\n    }\n\n    if (typeof size === 'number') {\n        return fixEncoder(encoding, size);\n    }\n\n    return createEncoder({\n        getSizeFromValue: (value: string) => {\n            const contentSize = getEncodedSize(value, encoding);\n            return getEncodedSize(contentSize, size) + contentSize;\n        },\n        write: (value: string, bytes, offset) => {\n            const contentSize = getEncodedSize(value, encoding);\n            offset = size.write(contentSize, bytes, offset);\n            return encoding.write(value, bytes, offset);\n        },\n    });\n}\n\n/** Decodes strings from a given encoding and size strategy. */\nexport function getStringDecoder<TSize extends number>(\n    config: StringCodecConfig<NumberDecoder, Decoder<string>> & { size: TSize },\n): FixedSizeDecoder<string, TSize>;\nexport function getStringDecoder<TSize extends number>(\n    config: StringCodecConfig<NumberDecoder, Decoder<string>> & {\n        encoding: FixedSizeDecoder<string, TSize>;\n        size: 'variable';\n    },\n): FixedSizeDecoder<string, TSize>;\nexport function getStringDecoder(\n    config?: StringCodecConfig<NumberDecoder, Decoder<string>>,\n): VariableSizeDecoder<string>;\nexport function getStringDecoder(config: StringCodecConfig<NumberDecoder, Decoder<string>> = {}): Decoder<string> {\n    const size = config.size ?? getU32Decoder();\n    const encoding = config.encoding ?? getUtf8Decoder();\n\n    if (size === 'variable') {\n        return encoding;\n    }\n\n    if (typeof size === 'number') {\n        return fixDecoder(encoding, size);\n    }\n\n    return createDecoder({\n        read: (bytes: Uint8Array, offset = 0) => {\n            assertByteArrayIsNotEmptyForCodec('string', bytes, offset);\n            const [lengthBigInt, lengthOffset] = size.read(bytes, offset);\n            const length = Number(lengthBigInt);\n            offset = lengthOffset;\n            const contentBytes = bytes.slice(offset, offset + length);\n            assertByteArrayHasEnoughBytesForCodec('string', length, contentBytes);\n            const [value, contentOffset] = encoding.read(contentBytes, 0);\n            offset += contentOffset;\n            return [value, offset];\n        },\n    });\n}\n\n/** Encodes and decodes strings from a given encoding and size strategy. */\nexport function getStringCodec<TSize extends number>(\n    config: StringCodecConfig<NumberCodec, Codec<string>> & { size: TSize },\n): FixedSizeCodec<string, string, TSize>;\nexport function getStringCodec<TSize extends number>(\n    config: StringCodecConfig<NumberCodec, Codec<string>> & {\n        encoding: FixedSizeCodec<string, string, TSize>;\n        size: 'variable';\n    },\n): FixedSizeCodec<string, string, TSize>;\nexport function getStringCodec(config?: StringCodecConfig<NumberCodec, Codec<string>>): VariableSizeCodec<string>;\nexport function getStringCodec(config: StringCodecConfig<NumberCodec, Codec<string>> = {}): Codec<string> {\n    return combineCodec(getStringEncoder(config), getStringDecoder(config));\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): Codec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n"],"mappings":";AAAA,SAASA,aAAA,EAAAC,aAAA,EAAAC,YAAA,EAAAC,UAA+C,EAAAC,cAAmB,EAAAC,UAAA,EAAAC,iCAAA,EAAAC,qCAAA;AAKpE,SAASC,aAAA,EAAAC,aAAsB,QAAkB,wBAAgC;;AAEhF;AAAqE,SACjEC,sBAAAC,SAAA,EAAAC,SAAA,EAAAC,UAAA,GAAAD,SAAA;EAAA,IACA,CAAAA,SAAM,CAAAE,KAAS,KAAAC,MAAA,MAAAJ,SAAA;IAAA,MACf,IAAOK,WAAA,CAAAC,6CAAA;MACVC,QAAA,EAAAP,SAAA;MACLQ,IAAA,EAAAR,SAAA,CAAAS,MAAA;MACJC,KAAA,EAAAR;;;ACbA;AAAA,IACIS,eAAA,GAAAX,SAAA;EACA,OAAAX,aAAA;IACAuB,gBAAA,EAAAF,KAAA;MAAA,MAIG,CAAAG,aAAA,EAAAC,SAAA,IAAAC,sBAAA,CAAAL,KAAA,EAAAV,SAAA;MASM,KAAAc,SAAA,EACT,OAAOJ,KAAA,CAAAD,MAAc;MACjB,MAAAO,YAAmB,GAAAC,kBAA0B,CAAAH,SAAA,EAAAd,SAAA;MACzC,OAAOa,aAAA,CAAAJ,MAAe,GAAAS,IAAS,CAAIC,IAAA,CAAAH,YAAA,CAAAI,QAAuB,IAAO,CAAAX,MAAA,GAAS,CAAC,CAAC;IAC5E;IAAgBY,MAAAX,KAAO,EAAAY,KAAM,EAAAC,MAAA;MAE7BxB,qBAAqB,CAAAC,SAAA,EAAAU,KAAA;MACrB,IAAAA,KAAO,SACX,OAAAa,MAAA;MACA,MAAM,CAAAV,aAAsB,EAAAC,SAAQ,IAAAC,sBAAA,CAAAL,KAAA,EAAAV,SAAA;MAEhC,KAAAc,SAAA;QACAQ,KAAI,CAAAE,GAAA,KAAUC,UAAA,CAAAZ,aAAA,CAAAJ,MAAA,EAAAiB,IAAA,KAAAH,MAAA;QAAI,OAAOA,MAAA,GAAAV,aAAA,CAAAJ,MAAA;MAGzB;MACA,IAAIO,YAAY,GAAAC,kBAAA,CAAAH,SAAA,EAAAd,SAAA;MACZ,MAAA2B,SAAU,GAAI;MACd,OAAAX,YAAgB;QACpBW,SAAA,CAAAC,OAAA,CAAAC,MAAA,CAAAb,YAAA;QAGAA,YAAI,QAAe;MAGnB;MACA,MAAAc,UAAO,OAAeC,KAAI,CAAAlB,aAAA,CAAAJ,MAAA,EAAAiB,IAAA,QAAAC,SAAA;MACtBL,KAAA,CAAAE,GAAA,CAAAM,UAAkB,EAAAP,MAAO;MACzB,OAAAA,MAAA,GAAAO,UAAgB,CAAArB,MAAA;IAAA;EAGpB;AACA;AACA,IAAAuB,eAAO,GAAShC,SAAA,IAAW;EAAA,OAC/BV,aAAA;IACH2C,KAAAC,QAAA,EAAAX,MAAA;MACL,MAAAD,KAAA,GAAAC,MAAA,SAAAW,QAAA,GAAAA,QAAA,CAAAC,KAAA,CAAAZ,MAAA;MAOa,IAAAD,KAAA,CAAAb,MAAkB,KAAC,GAC5B,OAAO;MACH,IAAK2B,UAAU,GAAAd,KAA0B,CAAAe,SAAA,CAAAC,CAAA,IAAAA,CAAA;MACrCF,UAAM,GAAAA,UAAQ,KAAW,CAAI,IAAAd,KAAA,CAAAb,MAAW,GAAA2B,UAAe;MACvD,MAAIvB,aAAM,GAAWb,SAAA,IAAAuC,MAAA,CAAAH,UAAA;MAAG,IAAAA,UAAY,KAACd,KAAA,CAAAb,MAAA,EAGrC,OAAI,CAAAI,aAAmB,EAAAqB,QAAU,CAAAzB,MAAK;MACtC,MAAAO,YAAa,GAAAM,KAAA,CAAAa,KAAe,CAAKC,UAAM,EAAAI,MAAS,EAAAC,GAAA,EAAAC,IAAA,KAAAD,GAAA,UAAAE,MAAA,CAAAD,IAAA;MAChD,MAAM5B,SAAA,GAAA8B,kBAA4B,CAAA5B,YAAO,EAAAhB,SAAU;MACnD,OAAI,CAAAa,aAAe,GAAAC,SAAM,EAAAoB,QAAA,CAAAzB,MAAA;IAAQ;EAGjC;AAGA;AAEA,IAAAoC,aAAQ,GAAA7C,SAAgB,IAAAT,YAAW,CAAAoB,eAAe,CAAAX,SAAA,GAAAgC,eAAA,CAAAhC,SAAA;AAAA,SACtDe,uBAAAL,KAAA,EAAAoC,aAAA;EACJ,MAAC,CAAAC,YAAA,EAAAjC,SAAA,IAAAJ,KAAA,CAAAsC,KAAA,KAAA5C,MAAA,QAAA0C,aAAA;EACL,QAAAC,YAAA,EAAAjC,SAAA;AAWO;AAGP,SAASG,mBAAAP,KACL,EAAAV,SACA;EAEA,MAAMQ,IAAC,GAAAmC,MAAA,CAAA3C,SAAc,CAASS,MAAI;EAClC,IAAAgC,GAAO,GAAC;EACZ,WAAAQ,IAAA,IAAAvC,KAAA;IAEA+B,GAAA,IAASjC,IAAA;IACLiC,GAAA,IAAME,MAAO,CAAA3C,SAAO,CAAAkD,OAAS,CAAAD,IAAM;EACnC;EACA,OAAAR,GAAA;AACI;AACA,SAAAG,kBAAcA,CAASlC,KAAA,EAAAV,SAAa;EACxC,MAAAQ,IAAA,GAAAmC,MAAA,CAAA3C,SAAA,CAAAS,MAAA;EACA,MAAAK,SAAO;EACX,OAAAJ,KAAA;IAEAI,SAAS,CAAAc,OAAA,CAAA5B,SAAmB,CAAA6B,MAAe,CAAAnB,KAAA,GAA0BF,IAAA;IACjEE,KAAM,IAAAF,IAAO;EACb;EACA,OAAOM,SAAQ,CAAAqC,IAAI;AACf;;AACS;AAEb,IAAA5C,QAAO,eAAiB;AAC5B,IAAA6C,gBAAA,GAAAA,CAAA,KAAAzC,eAAA,CAAAJ,QAAA;;;ACtHA,IAAM8C,gBAAW,GAAAA,CAAA,KAAAhE,aAAA;EAGVuB,gBAAM,EAAAF,KAAmB,IAAMQ,IAAA,CAAAC,IAAA,CAAAT,KAAgB,CAAAD,MAAQ;EAGvDY,KAAMA,CAAAX,KAAA,EAAAY,KAAA,EAAAC,MAAmB,EAAM;IAGzB,MAAA+B,cAAiB,GAAM5C,KAAA,CAAA6C,WAAc;;;ICXlD,MAAAC,QAAA,GAAAC,OAAA,GAAAA,OAAA,CAAAC,GAAA,CAAAhB,IAAA,IAAAiB,QAAA,CAAAjB,IAAA;IACIpB,KAAA,CAAAE,GAAA,CAAAgC,QAAA,EAAAjC,MAAA;IACA,OAAAiC,QAAA,CAAA/C,MAAA,GAAAc,MAAA;EACA;AAAA;AASG,IAAMqC,gBAAA,GAAmBA,CAAA,KAC5BtE,aAAA;EACI2C,KAAAX,KAAA,EAAAC,MAAkB,EAAC;IACnB,MAAMb,KAAe,GAAAY,KAAO,CAAAa,KAAA,CAAQZ,MAAA,EAAAiB,MAAA,EAAAqB,GAAA,EAAAnB,IAAA,KAAAmB,GAAA,GAAAnB,IAAA,CAAAtB,QAAA,KAAA0C,QAAA;IAChC,OAAM,CAAApD,KAAA,EAAAY,KAAA,CAAAb,MAAiB;EACvB;AACA;AACA,IAAAsD,cAAM,GAAWA,CAAA,KAAAxE,YAAkB,CAAA8D,gBAAsB,IAAAO,gBAAuB;;AAEhF;AAAyB,IAC7BI,SAAA;AACJ,IAACC,gBAAA,GAAAA,CAAA,KAAAtD,eAAA,CAAAqD,SAAA;AAGE,IAAME,gBAAA,GAAmBA,CAAA,KAC5BlC,eAAc,CAAAgC,SAAA;AAAA,IACVG,cAAY,GAAAA,CAAA,KAAQtB,aAAA,CAAAmB,SAAA;AAChB,IAAAI,sBAAoB,GAAAA,CAAMpE,SAAQ,EAAAqE,IAAO,KAAChF,aAAc;EACxDuB,gBAAQ,EAAOF,KAAM,IAAMQ,IAAA,CAAAoD,KAAA,CAAA5D,KAAA,CAAAD,MAAA,GAAA4D,IAAA;EAC/BhD,MAAAX,KAAA,EAAAY,KAAA,EAAAC,MAAA;IACHxB,qBAAA,CAAAC,SAAA,EAAAU,KAAA;IAGQ,IAAAA,KAAA,S;;ICjCP,MAAA6D,aAAW,GAAAC,OAAA,CAAAC,WAAA,EAAAJ,IAAA;IAGJ/C,KAAA,CAAAE,GAAA,CAAA+C,aAAmB,EAAMhD,MAAA;IAGzB,OAAAgD,aAAmB,CAAA9D,MAAM,GAAAc,MAAA;EAG/B;;;ECXPU,KAAAC,QAAA,EAAAX,MAAA;IACI,MAAAD,KAAA,GAAAC,MAAA,SAAAW,QAAA,GAAAA,QAAA,CAAAC,KAAA,CAAAZ,MAAA;IACA,IAAAD,KAAA,CAAAb,MAAA,QACA,YAAAyB,QAAA,CAAAzB,MAAA;IACA,MAAAgE,WAAA,GAAAD,OAAA,KAAAlD,KAAA,MAAA+C,IAAA;IACA,QAAAI,WAAA,CAAAf,GAAA,CAAAgB,CAAA,IAAA1E,SAAA,CAAA0E,CAAA,GAAAvB,IAAA,MAAAjB,QAAA,CAAAzB,MAAA;EAAA;AAKJ;;;ECVA,MAAAkE,MAAA;EACI,IAAAC,WAAA;EACA,IAAAC,iBAAA;EACA,MAAAC,IAAA,SAAAC,UAAA;EAAA,KAIG,MAAArE,KAAA,IAAAsE,KAAA;IAQMJ,WAAA,GAAAA,WAAyB,IAACK,SAAkB,GAAAvE,KACrD;IACImE,iBAAmB,IAAAI,SAAkB;IACrC,OAAMJ,iBAAsB,IAAQE,UAAA;MAChCF,iBAAA,IAAsBE,UAAU;MAChCJ,MAAI,CAAAO,IAAA,CAAUN,WAAA,IAAAC,iBAAA,GAAAC,IAAA;IAAI;EAClB;EACA,IAAAK,YAAM,IAAAN,iBAAwB;IAC9BF,MAAM,CAAAO,IAAI,CAAAN,WAAA,IAAeG,UAAM,GAAAF,iBAAA,GAAAC,IAAA;EAC/B;EACJ,OAAAH,MAAA;AACJ;;AAOc;AAEN,IAAAS,SAAM,qEAAuD;AAC7D,IAAAC,gBAAU,GAAAA,CAAA,KAAW;EAAG;IACxB,OAAMhG,aAAc;MACpBuB,gBAAQ,EAAYF,KAAI,IAAK;QACjC;UACH,OAAA4E,IAAA,CAAA5E,KAAA,EAAAD,MAAA;QASQ,SAAA8E,EAAA;UAIJ,UAAQlF,WAAiB,CAAAC,6CAAwE;YAChGC,QAAU,EAAA6E,SAAA;YACZ5E,IAAA,IAAc;YACdE;UACE;QACN;MACI;MACAW,MAAAX,KAAA,EAAAY,KAAA,EAAqBC,MAAA;QACrB,IAAO;UACH,MAAAO,UAAA,GAAqBwD,IAAA,CAAA5E,KAAA,EAAAsC,KAAA,KAAAU,GAAA,CAAA8B,CAAA,IAAAA,CAAA,CAAAC,UAAA;UACrBnE,KAAO,CAAAE,GAAM,CAAAM,UAAA,EAAAP,MAAe;UAChC,OAAAO,UAAA,CAAArB,MAAA,GAAAc,MAAA;QACJ,SAAAgE,EAAA;UACI,UAAAlF,WAAgB,CAAAC,6CAAuB;YAChCC,QAAM,EAAA6E,SAAgB;YACjC5E,IAAA;YACOE;UACX;;;IDvDM;EAGC;AACH;AACI,IAAAgF,gBAAO,GAAAA,CAAA,KAAc;EAAA;IAEb,OAAApG,aAAI;MACA2C,KAAAX,KAAA,EAAQC,MAAwB,GAAK,GAAE;QAC3C,MAAAY,KAAS,GAAGb,KAAA,CAAAa,KAAA,CAAAZ,MAAA;QACR,MAAAb,KAAM,GAAIiF,IAAA,CAAAC,MAAY,CAAAC,YAAA,IAAA1D,KAAA;QAA+C,OACjE,CAAAzB,KAAA,EAAAY,KAAA,CAAAb,MAAA;MAAA;IACM;EACN;AACH;AACL,IAAAqF,cACJ,GAAAA,CAAA,KAAAvG,YAAA,CAAA8F,gBAAA,IAAAK,gBAAA;;AAEI;AACI,IAAAK,oBAAM,GAAArF,KAAc;AAGpB;AACAA,KAAA,CAAAsF,OAAA,UAAO,IAAW,CAAS;AAE3B,IAAAC,iBAAU,GAAAA,CAAAvF,KAAA,EAAAwF,KAAY,KAAAxF,KAAA,CAAAyF,MAAA,CAAAD,KAAA;;AAClB;AACM,IAAAE,CAAA,GAAAC,UACN,CAAAC,WAAA;AAAA,IAAAC,CAAA,GAAAF,UACH,CAAAG,WAAA;;AACL;AACJ,IACJC,cAAC,GAAAA,CAAA;EACL,IAAAC,WAAA;EAEA,OAAIrH,aAAY;IACZuB,gBAAO,EAAAF,KAAc,KAAAgG,WAAA,SAAAH,CAAA,IAAAI,MAAA,CAAAjG,KAAA,EAAAD,MAAA;IAAAY,KACjB,EAAAA,CAAAX,KAAA,EAAAY,KAAkB,EAACC,MAAA,KAAkB;MACrC,MAAMO,UAAe,IAAO4E,WAAQ,SAAAH,CAAA,IAAAI,MAAA,CAAAjG,KAAA;MAChCY,KAAA,CAAAE,GAAA,CAAAM,UAAA,EAAAP,MAAsB;MACtB,OAAAA,MAAM,GAAAO,UAAgB,CAAArB,MAAK;IAC3B;EACA;AAAuB;AAC3B,IACJmG,cAAC,GAAAA,CAAA;EACL,IAAAC,WAAA;EAEA,OAAOvH,aAAW;IACtB2C,KAAAX,KAAA,EAAAC,MAAA;MAGa,MAAAb,KAAA,IAAAmG,WAAsD,SAAAT,CAAA,IAAAU,MAAA,CAAAxF,KAAA,CAAAa,KAAA,CAAAZ,MAAA;MAC3D,OAAa,CAAAwE,oBAAA,CAAArF,KAAA,GAAAY,KAAA,CAAAb,MAAA;IACb;EAAqB;AAEb;AACA,IAAAsG,YAAM,GAAAA,CAAA,KAASxH,YAA+B,CAAAkH,cAAgB,IAAMG,cAAA;;AACzC;AAC/B,SACHI,iBAAAC,MAAA;EACL,MAAAC,IAAA,GAAAD,MAAA,CAAAC,IAAA,IAAArH,aAAA;EAEA,MAAIsH,QAAY,GAAAF,MAAA,CAAAE,QAAA,IAAAV,cAAA;EACZ,IAAAS,IAAA,KAAO,YAAc;IAAA,OACjBC,QAAO;EAAkF;EAEjG,WAAAD,IAAA;IAEA,OAAO1H,UAAA,CAAA2H,QAAA,EAAAD,IAAA;EAAA;EAA6C,OAAI7H,aAC9C;IACVuB,gBAAA,EAAAF,KAAA;MACJ,MAAA0G,WAAA,GAAA3H,cAAA,CAAAiB,KAAA,EAAAyG,QAAA;MAGa,OAAA1H,cAAkD,CAAA2H,WAAA,EAAaF,IAAA,IAAAE,WAAiB;;;MExFhF,MAAAA,WAAA,GAAA3H,cAAwB,CAAAiB,KAAA,EAAAyG,QAAA;MAAA5F,MAAA,GAAA2F,IAAA,CAAA7F,KAAA,CAAA+F,WAAA,EAAA9F,KAAA,EAAAC,MAAA;MAEjC,OAAM4F,QAAQ,CAAA9F,KAAW,CAAAX,KAAE,EAAAY,KAAA,EAAAC,MAAA;IAAA;EAGxB,EAAM;;;ECNb,MAAA2F,IAAA,GAAAD,MAAA,CAAAC,IAAA,IAAApH,aAAA;EACI,MAAAqH,QAAA,GAAAF,MAAA,CAAAE,QAAA,IAAAP,cAAA;EACA,IAAAM,IAAA;IAEA,OAAAC,QAAA;EACA;EACA,WAAAD,IAAA;IAGA,OAAAxH,UAAA,CAAAyH,QAAA,EAAAD,IAAA;EAIA;EACA,OAAA5H,aAAA;IAAA2C,IAIG,EAAAA,CAAAX,KAAA,EAAAC,MAAA;MACP5B,iCAAwB,SAAgE,EAAA2B,KAAA,EAAAC,MAAA;;;MCnBxFA,MAAA,GAAA8F,YAAA;MAEI,MAAAC,YAAA,GAAAhG,KAAA,CAAAa,KAAA,CAAAZ,MAAA,EAAAA,MAAA,GAAAd,MAAA;MACAb,qCAAA,WAAAa,MAAA,EAAA6G,YAAA;MACA,OAAA5G,KAAA,EAAA6G,aAAA,IAAAJ,QAAA,CAAAlF,IAAA,CAAAqF,YAAA;MAAA/F,MAGG,IAAAgG,aAAA;;;ECPA,EAAM;AAAN;;;ADaA;AAEH,SAAOxH,qBAAc,EAAAyH,cAAA,EAAAC,gBAAA,EAAArE,gBAAA,EAAAW,cAAA,EAAAH,gBAAA,EAAAP,gBAAA,EAAAc,cAAA,EAAAD,gBAAA,EAAAD,gBAAA,EAAA6B,cAAA,EAAAJ,gBAAA,EAAAL,gBAAA,EAAAxC,aAAA,EAAAb,eAAA,EAAArB,eAAA,EAAA+G,oBAAA,EAAAC,sBAAA,EAAAvD,sBAAA,EAAAwD,cAAA,EAAAC,gBAAA,EAAAb,gBAAA,EAAAD,YAAA,EAAAH,cAAA,EAAAH,cAAA,EAAAR,iBAAA,EAAAF,oBAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE } from '@solana/errors';\nimport { createEncoder, createDecoder, combineCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n      alphabet: alphabet4,\n      base: alphabet4.length,\n      value: givenValue\n    });\n  }\n}\nvar getBaseXEncoder = alphabet4 => {\n  return createEncoder({\n    getSizeFromValue: value => {\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) return value.length;\n      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n    },\n    write(value, bytes, offset) {\n      assertValidBaseString(alphabet4, value);\n      if (value === \"\") return offset;\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) {\n        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n        return offset + leadingZeroes.length;\n      }\n      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      const tailBytes = [];\n      while (base10Number > 0n) {\n        tailBytes.unshift(Number(base10Number % 256n));\n        base10Number /= 256n;\n      }\n      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getBaseXDecoder = alphabet4 => {\n  return createDecoder({\n    read(rawBytes, offset) {\n      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n      if (bytes.length === 0) return [\"\", 0];\n      let trailIndex = bytes.findIndex(n => n !== 0);\n      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n      const leadingZeroes = alphabet4[0].repeat(trailIndex);\n      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n      return [leadingZeroes + tailChars, rawBytes.length];\n    }\n  });\n};\nvar getBaseXCodec = alphabet4 => combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n  return [leadingZeros, tailChars];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  let sum = 0n;\n  for (const char of value) {\n    sum *= base;\n    sum += BigInt(alphabet4.indexOf(char));\n  }\n  return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  const tailChars = [];\n  while (value > 0n) {\n    tailChars.unshift(alphabet4[Number(value % base)]);\n    value /= base;\n  }\n  return tailChars.join(\"\");\n}\n\n// src/base10.ts\nvar alphabet = \"0123456789\";\nvar getBase10Encoder = () => getBaseXEncoder(alphabet);\nvar getBase10Decoder = () => getBaseXDecoder(alphabet);\nvar getBase10Codec = () => getBaseXCodec(alphabet);\nvar INVALID_STRING_ERROR_BASE_CONFIG = {\n  alphabet: \"0123456789abcdef\",\n  base: 16\n};\nfunction charCodeToBase16(char) {\n  if (char >= 48 /* ZERO */ && char <= 57 /* NINE */) return char - 48 /* ZERO */;\n  if (char >= 65 /* A_UP */ && char <= 70 /* F_UP */) return char - (65 /* A_UP */ - 10);\n  if (char >= 97 /* A_LO */ && char <= 102 /* F_LO */) return char - (97 /* A_LO */ - 10);\n}\nvar getBase16Encoder = () => createEncoder({\n  getSizeFromValue: value => Math.ceil(value.length / 2),\n  write(value, bytes, offset) {\n    const len = value.length;\n    const al = len / 2;\n    if (len === 1) {\n      const c = value.charCodeAt(0);\n      const n = charCodeToBase16(c);\n      if (n === void 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      bytes.set([n], offset);\n      return 1 + offset;\n    }\n    const hexBytes = new Uint8Array(al);\n    for (let i = 0, j = 0; i < al; i++) {\n      const c1 = value.charCodeAt(j++);\n      const c2 = value.charCodeAt(j++);\n      const n1 = charCodeToBase16(c1);\n      const n2 = charCodeToBase16(c2);\n      if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;\n    }\n    bytes.set(hexBytes, offset);\n    return hexBytes.length + offset;\n  }\n});\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nvar getBase16Codec = () => combineCodec(getBase16Encoder(), getBase16Decoder());\n\n// src/base58.ts\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = () => getBaseXEncoder(alphabet2);\nvar getBase58Decoder = () => getBaseXDecoder(alphabet2);\nvar getBase58Codec = () => getBaseXCodec(alphabet2);\nvar getBaseXResliceEncoder = (alphabet4, bits) => createEncoder({\n  getSizeFromValue: value => Math.floor(value.length * bits / 8),\n  write(value, bytes, offset) {\n    assertValidBaseString(alphabet4, value);\n    if (value === \"\") return offset;\n    const charIndices = [...value].map(c => alphabet4.indexOf(c));\n    const reslicedBytes = reslice(charIndices, bits, 8, false);\n    bytes.set(reslicedBytes, offset);\n    return reslicedBytes.length + offset;\n  }\n});\nvar getBaseXResliceDecoder = (alphabet4, bits) => createDecoder({\n  read(rawBytes, offset = 0) {\n    const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n    if (bytes.length === 0) return [\"\", rawBytes.length];\n    const charIndices = reslice([...bytes], 8, bits, true);\n    return [charIndices.map(i => alphabet4[i]).join(\"\"), rawBytes.length];\n  }\n});\nvar getBaseXResliceCodec = (alphabet4, bits) => combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));\nfunction reslice(input, inputBits, outputBits, useRemainder) {\n  const output = [];\n  let accumulator = 0;\n  let bitsInAccumulator = 0;\n  const mask = (1 << outputBits) - 1;\n  for (const value of input) {\n    accumulator = accumulator << inputBits | value;\n    bitsInAccumulator += inputBits;\n    while (bitsInAccumulator >= outputBits) {\n      bitsInAccumulator -= outputBits;\n      output.push(accumulator >> bitsInAccumulator & mask);\n    }\n  }\n  if (useRemainder && bitsInAccumulator > 0) {\n    output.push(accumulator << outputBits - bitsInAccumulator & mask);\n  }\n  return output;\n}\n\n// src/base64.ts\nvar alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar getBase64Encoder = () => {\n  {\n    return createEncoder({\n      getSizeFromValue: value => {\n        try {\n          return atob(value).length;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      },\n      write(value, bytes, offset) {\n        try {\n          const bytesToAdd = atob(value).split(\"\").map(c => c.charCodeAt(0));\n          bytes.set(bytesToAdd, offset);\n          return bytesToAdd.length + offset;\n        } catch (e2) {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      }\n    });\n  }\n};\nvar getBase64Decoder = () => {\n  {\n    return createDecoder({\n      read(bytes, offset = 0) {\n        const slice = bytes.slice(offset);\n        const value = btoa(String.fromCharCode(...slice));\n        return [value, bytes.length];\n      }\n    });\n  }\n};\nvar getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder());\n\n// src/null-characters.ts\nvar removeNullCharacters = value =>\n// eslint-disable-next-line no-control-regex\nvalue.replace(/\\u0000/g, \"\");\nvar padNullCharacters = (value, chars) => value.padEnd(chars, \"\\0\");\n\n// ../text-encoding-impl/dist/index.browser.mjs\nvar e = globalThis.TextDecoder;\nvar o = globalThis.TextEncoder;\n\n// src/utf8.ts\nvar getUtf8Encoder = () => {\n  let textEncoder;\n  return createEncoder({\n    getSizeFromValue: value => (textEncoder ||= new o()).encode(value).length,\n    write: (value, bytes, offset) => {\n      const bytesToAdd = (textEncoder ||= new o()).encode(value);\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getUtf8Decoder = () => {\n  let textDecoder;\n  return createDecoder({\n    read(bytes, offset) {\n      const value = (textDecoder ||= new e()).decode(bytes.slice(offset));\n      return [removeNullCharacters(value), bytes.length];\n    }\n  });\n};\nvar getUtf8Codec = () => combineCodec(getUtf8Encoder(), getUtf8Decoder());\nexport { assertValidBaseString, getBase10Codec, getBase10Decoder, getBase10Encoder, getBase16Codec, getBase16Decoder, getBase16Encoder, getBase58Codec, getBase58Decoder, getBase58Encoder, getBase64Codec, getBase64Decoder, getBase64Encoder, getBaseXCodec, getBaseXDecoder, getBaseXEncoder, getBaseXResliceCodec, getBaseXResliceDecoder, getBaseXResliceEncoder, getUtf8Codec, getUtf8Decoder, getUtf8Encoder, padNullCharacters, removeNullCharacters };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["createEncoder","createDecoder","combineCodec","assertValidBaseString","alphabet4","testValue","givenValue","match","RegExp","SolanaError","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","alphabet","base","length","value","getBaseXEncoder","getSizeFromValue","leadingZeroes","tailChars","partitionLeadingZeroes","base10Number","getBigIntFromBaseX","Math","ceil","toString","write","bytes","offset","set","Uint8Array","fill","tailBytes","unshift","Number","bytesToAdd","Array","getBaseXDecoder","read","rawBytes","slice","trailIndex","findIndex","n","repeat","reduce","sum","byte","BigInt","getBaseXFromBigInt","getBaseXCodec","zeroCharacter","leadingZeros","split","char","indexOf","join","getBase10Encoder","getBase10Decoder","charCodeToBase16","getBase16Encoder","len","al","c","charCodeAt","INVALID_STRING_ERROR_BASE_CONFIG","hexBytes","i","j","c1","c2","n1","n2","isNaN","getBase16Decoder","str","padStart","getBase16Codec","alphabet2","getBase58Encoder","getBase58Decoder","getBase58Codec","getBaseXResliceEncoder","bits","floor","charIndices","map","reslicedBytes","reslice","getBaseXResliceDecoder","getBaseXResliceCodec","input","inputBits","outputBits","useRemainder","output","accumulator","bitsInAccumulator","push","mask","alphabet3","getBase64Encoder","atob","e2","getBase64Decoder","btoa","String","fromCharCode","getBase64Codec","removeNullCharacters","replace","padNullCharacters","chars","padEnd","e","globalThis","TextDecoder","o","TextEncoder","getUtf8Encoder","textEncoder","encode","getUtf8Decoder","textDecoder","decode","getUtf8Codec","getBase10Codec"],"sources":["/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/assertions.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/baseX.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/base10.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/base16.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/base58.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/base64.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/baseX-reslice.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/null-characters.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/codecs-strings/src/utf8.ts","/home/rochisha/solana-token-ui/node_modules/@solana/spl-token-group/node_modules/@solana/text-encoding-impl/src/index.browser.ts"],"sourcesContent":["import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch (e) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
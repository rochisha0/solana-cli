{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH } from '@solana/errors';\n\n// src/assertions.ts\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n  if (bytes.length - offset <= 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n      codecDescription\n    });\n  }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n  const bytesLength = bytes.length - offset;\n  if (bytesLength < expected) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n      bytesLength,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n  if (offset < 0 || offset > bytesLength) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n      bytesLength,\n      codecDescription,\n      offset\n    });\n  }\n}\n\n// src/bytes.ts\nvar mergeBytes = byteArrays => {\n  const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n  if (nonEmptyByteArrays.length === 0) {\n    return byteArrays.length ? byteArrays[0] : new Uint8Array();\n  }\n  if (nonEmptyByteArrays.length === 1) {\n    return nonEmptyByteArrays[0];\n  }\n  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  nonEmptyByteArrays.forEach(arr => {\n    result.set(arr, offset);\n    offset += arr.length;\n  });\n  return result;\n};\nvar padBytes = (bytes, length) => {\n  if (bytes.length >= length) return bytes;\n  const paddedBytes = new Uint8Array(length).fill(0);\n  paddedBytes.set(bytes);\n  return paddedBytes;\n};\nvar fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction getEncodedSize(value, encoder) {\n  return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n  return Object.freeze({\n    ...encoder,\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, encoder));\n      encoder.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction createDecoder(decoder) {\n  return Object.freeze({\n    ...decoder,\n    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]\n  });\n}\nfunction createCodec(codec) {\n  return Object.freeze({\n    ...codec,\n    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, codec));\n      codec.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction isFixedSize(codec) {\n  return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n  if (!isFixedSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n  }\n}\nfunction isVariableSize(codec) {\n  return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n  if (!isVariableSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n  }\n}\nfunction combineCodec(encoder, decoder) {\n  if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n  }\n  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n      decoderFixedSize: decoder.fixedSize,\n      encoderFixedSize: encoder.fixedSize\n    });\n  }\n  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n      decoderMaxSize: decoder.maxSize,\n      encoderMaxSize: encoder.maxSize\n    });\n  }\n  return {\n    ...decoder,\n    ...encoder,\n    decode: decoder.decode,\n    encode: encoder.encode,\n    read: decoder.read,\n    write: encoder.write\n  };\n}\n\n// src/fix-codec.ts\nfunction fixEncoder(encoder, fixedBytes) {\n  return createEncoder({\n    fixedSize: fixedBytes,\n    write: (value, bytes, offset) => {\n      const variableByteArray = encoder.encode(value);\n      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n      bytes.set(fixedByteArray, offset);\n      return offset + fixedBytes;\n    }\n  });\n}\nfunction fixDecoder(decoder, fixedBytes) {\n  return createDecoder({\n    fixedSize: fixedBytes,\n    read: (bytes, offset) => {\n      assertByteArrayHasEnoughBytesForCodec(\"fixCodec\", fixedBytes, bytes, offset);\n      if (offset > 0 || bytes.length > fixedBytes) {\n        bytes = bytes.slice(offset, offset + fixedBytes);\n      }\n      if (isFixedSize(decoder)) {\n        bytes = fixBytes(bytes, decoder.fixedSize);\n      }\n      const [value] = decoder.read(bytes, 0);\n      return [value, offset + fixedBytes];\n    }\n  });\n}\nfunction fixCodec(codec, fixedBytes) {\n  return combineCodec(fixEncoder(codec, fixedBytes), fixDecoder(codec, fixedBytes));\n}\n\n// src/map-codec.ts\nfunction mapEncoder(encoder, unmap) {\n  return createEncoder({\n    ...(isVariableSize(encoder) ? {\n      ...encoder,\n      getSizeFromValue: value => encoder.getSizeFromValue(unmap(value))\n    } : encoder),\n    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)\n  });\n}\nfunction mapDecoder(decoder, map) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      return [map(value, bytes, offset), newOffset];\n    }\n  });\n}\nfunction mapCodec(codec, unmap, map) {\n  return createCodec({\n    ...mapEncoder(codec, unmap),\n    read: map ? mapDecoder(codec, map).read : codec.read\n  });\n}\n\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n      const postOffset = encoder.write(value, bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n      return newPostOffset;\n    }\n  });\n}\nfunction offsetDecoder(decoder, config) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n      const [value, postOffset] = decoder.read(bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n      return [value, newPostOffset];\n    }\n  });\n}\nfunction offsetCodec(codec, config) {\n  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n  if (divisor === 0) return 0;\n  return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n  if (isFixedSize(encoder)) {\n    const fixedSize = resize(encoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeEncoder\"\n      });\n    }\n    return createEncoder({\n      ...encoder,\n      fixedSize\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    getSizeFromValue: value => {\n      const newSize = resize(encoder.getSizeFromValue(value));\n      if (newSize < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n          bytesLength: newSize,\n          codecDescription: \"resizeEncoder\"\n        });\n      }\n      return newSize;\n    }\n  });\n}\nfunction resizeDecoder(decoder, resize) {\n  if (isFixedSize(decoder)) {\n    const fixedSize = resize(decoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeDecoder\"\n      });\n    }\n    return createDecoder({\n      ...decoder,\n      fixedSize\n    });\n  }\n  return decoder;\n}\nfunction resizeCodec(codec, resize) {\n  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    preOffset: ({\n      preOffset\n    }) => preOffset + offset\n  });\n}\nfunction padRightEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    postOffset: ({\n      postOffset\n    }) => postOffset + offset\n  });\n}\nfunction padLeftDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    preOffset: ({\n      preOffset\n    }) => preOffset + offset\n  });\n}\nfunction padRightDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    postOffset: ({\n      postOffset\n    }) => postOffset + offset\n  });\n}\nfunction padLeftCodec(codec, offset) {\n  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n\n// src/reverse-codec.ts\nfunction reverseEncoder(encoder) {\n  assertIsFixedSize(encoder);\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, offset) => {\n      const newOffset = encoder.write(value, bytes, offset);\n      const slice = bytes.slice(offset, offset + encoder.fixedSize).reverse();\n      bytes.set(slice, offset);\n      return newOffset;\n    }\n  });\n}\nfunction reverseDecoder(decoder) {\n  assertIsFixedSize(decoder);\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const reverseEnd = offset + decoder.fixedSize;\n      if (offset === 0 && bytes.length === reverseEnd) {\n        return decoder.read(bytes.reverse(), offset);\n      }\n      const reversedBytes = bytes.slice();\n      reversedBytes.set(bytes.slice(offset, reverseEnd).reverse(), offset);\n      return decoder.read(reversedBytes, offset);\n    }\n  });\n}\nfunction reverseCodec(codec) {\n  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\nexport { assertByteArrayHasEnoughBytesForCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayOffsetIsNotOutOfRange, assertIsFixedSize, assertIsVariableSize, combineCodec, createCodec, createDecoder, createEncoder, fixBytes, fixCodec, fixDecoder, fixEncoder, getEncodedSize, isFixedSize, isVariableSize, mapCodec, mapDecoder, mapEncoder, mergeBytes, offsetCodec, offsetDecoder, offsetEncoder, padBytes, padLeftCodec, padLeftDecoder, padLeftEncoder, padRightCodec, padRightDecoder, padRightEncoder, resizeCodec, resizeDecoder, resizeEncoder, reverseCodec, reverseDecoder, reverseEncoder };\n//# sourceMappingURL=out.js.map","map":{"version":3,"names":["assertByteArrayIsNotEmptyForCodec","codecDescription","bytes","offset","length","SolanaError","SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY","assertByteArrayHasEnoughBytesForCodec","expected","bytesLength","SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH","assertByteArrayOffsetIsNotOutOfRange","SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE","mergeBytes","byteArrays","nonEmptyByteArrays","filter","arr","totalLength","reduce","total","result","Uint8Array","forEach","set","padBytes","paddedBytes","fill","fixBytes","slice","getEncodedSize","value","encoder","fixedSize","getSizeFromValue","createEncoder","encode","write","createDecoder","decoder","Object","freeze","decode","read","createCodec","codec","isFixedSize","assertIsFixedSize","SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH","isVariableSize","assertIsVariableSize","SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH","combineCodec","SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH","SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH","decoderFixedSize","encoderFixedSize","maxSize","encoderMaxSize","fixEncoder","fixedBytes","variableByteArray","fixedByteArray","fixDecoder","fixCodec","mapEncoder","unmap","mapDecoder","map","newOffset","mapCodec","offsetEncoder","config","preOffset","wrapBytes","modulo","newPreOffset","postOffset","newPostOffset","offsetDecoder","offsetCodec","dividend","divisor","resizeEncoder","resize","SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH","newSize","resizeDecoder","resizeCodec","padLeftEncoder","size","padRightEncoder","padLeftDecoder","padRightDecoder","padLeftCodec","padRightCodec","reverseEncoder","reverse","reverseDecoder","reverseEnd","reversedBytes","reverseCodec"],"sources":["/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/assertions.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/bytes.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/combine-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/fix-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/map-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/offset-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/resize-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/pad-codec.ts","/home/rochisha/solana-token-ui/node_modules/@solana/codecs-core/src/reverse-codec.ts"],"sourcesContent":["import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(codecDescription: string, bytes: Uint8Array, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: Uint8Array, length: number): Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: Uint8Array, length: number): Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => Uint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoder<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoder<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes: Uint8Array, offset: Offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodec', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoder(codec, fixedBytes), fixDecoder(codec, fixedBytes));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function mapEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function mapEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function mapEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function mapEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function mapDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function mapDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function mapDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function mapDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function mapCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function mapCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function mapCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function mapCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function mapCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function mapCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function mapCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...mapEncoder(codec, unmap),\n        read: map ? mapDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function offsetEncoder<TEncoder extends Encoder<any>>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function offsetDecoder<TDecoder extends Decoder<any>>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function offsetCodec<TCodec extends Codec<any>>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Updates the size of a given encoder.\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeEncoder<TEncoder extends Encoder<any>>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeEncoder<TEncoder extends Encoder<any>>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeDecoder<TDecoder extends Decoder<any>>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeDecoder<TDecoder extends Decoder<any>>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeCodec<TCodec extends Codec<any>>(codec: TCodec, resize: (size: number) => number): TCodec;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function resizeCodec<TCodec extends Codec<any>>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n/**\n * Adds left padding to the given encoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padLeftEncoder<TEncoder extends Encoder<any>>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padRightEncoder<TEncoder extends Encoder<any>>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padLeftDecoder<TDecoder extends Decoder<any>>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padRightDecoder<TDecoder extends Decoder<any>>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padLeftCodec<TCodec extends Codec<any>>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function padRightCodec<TCodec extends Codec<any>>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            const slice = bytes.slice(offset, offset + encoder.fixedSize).reverse();\n            bytes.set(slice, offset);\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reverseEnd = offset + decoder.fixedSize;\n            if (offset === 0 && bytes.length === reverseEnd) {\n                return decoder.read(bytes.reverse(), offset);\n            }\n            const reversedBytes = bytes.slice();\n            reversedBytes.set(bytes.slice(offset, reverseEnd).reverse(), offset);\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n"],"mappings":";;AAAA;AACI,SACAA,kCAAAC,gBAAA,EAAAC,KAAA,EAAAC,MAAA;EACA,IAAAD,KAAA,CAAAE,MAAA,GAAAD,MAAA;IACA,UAAAE,WAAA,CAAAC,oDAAA;MAAAL;IAMG;EACH;AACI;AAA4E,SACxEM,sCAAAN,gBAAA,EAAAO,QAAA,EAAAN,KAAA,EAAAC,MAAA;EAAA,MACHM,WAAA,GAAAP,KAAA,CAAAE,MAAA,GAAAD,MAAA;EACL,IAAAM,WAAA,GAAAD,QAAA;IACJ,UAAAH,WAAA,CAAAK,yCAAA;MAKOD,WAAS;MAMZR,gBAAoB;MAChBO;IACA;EAAiE;AAC7D;AACA,SACAG,qCAAAV,gBAAA,EAAAE,MAAA,EAAAM,WAAA;EAAA,IACHN,MAAA,QAAAA,MAAA,GAAAM,WAAA;IACL,UAAAJ,WAAA,CAAAO,yCAAA;MACJH,WAAA;MAQOR,gBAAS;MACRE;IACA;EAAiE;AAC7D;;AAEA;AACH,IACLU,UAAA,GAAAC,UAAA;EACJ,MAAAC,kBAAA,GAAAD,UAAA,CAAAE,MAAA,CAAAC,GAAA,IAAAA,GAAA,CAAAb,MAAA;;;EC/CO;EACH,IAAAW,kBAAM,CAAAX,MAAqB;IAC3B,OAAIW,kBAAmB;EACnB;EACJ,MAAAG,WAAA,GAAAH,kBAAA,CAAAI,MAAA,EAAAC,KAAA,EAAAH,GAAA,KAAAG,KAAA,GAAAH,GAAA,CAAAb,MAAA;EAEA,MAAIiB,MAAA,OAAAC,UAAmB,CAAAJ,WAAc;EACjC,IAAAf,MAAO;EACXY,kBAAA,CAAAQ,OAAA,CAAAN,GAAA;IAEAI,MAAM,CAAAG,GAAA,CAAAP,GAAA,EAAAd,MAAc;IACpBA,MAAM,IAAAc,GAAS,CAAAb,MAAI;EACnB;EACA,OAAAiB,MAAA;AACI;AACA,IAAAI,QAAA,GAAUA,CAAAvB,KAAI,EAAAE,MAAA;EAClB,IAACF,KAAA,CAAAE,MAAA,IAAAA,MAAA,EACD,OAAOF,KAAA;EACX,MAAAwB,WAAA,OAAAJ,UAAA,CAAAlB,MAAA,EAAAuB,IAAA;EAMOD,WAAM,CAAAF,GAAY,CAAAtB,KAAmB;EACxC,OAAIwB,WAAM;AAAkB;AAC5B,IAAAE,QAAM,GAAAA,CAAA1B,KAAA,EAAcE,MAAI,KAAAqB,QAAW,CAAMvB,KAAE,CAAAE,MAAM,IAAAA,MAAA,GAAAF,KAAA,GAAAA,KAAA,CAAA2B,KAAA,IAAAzB,MAAA,GAAAA,MAAA;AACjD,SAAA0B,cAAqBA,CAAAC,KAAA,EAAAC,OAAA;EACrB,OAAO,eAAAA,OAAA,GAAAA,OAAA,CAAAC,SAAA,GAAAD,OAAA,CAAAE,gBAAA,CAAAH,KAAA;AACX;AAOO,SAAMI,aAAYA,CAAmBH,OAAA;;;ICxC5CI,MAAA,EAAAL,KAAA;MACI,MAAA7B,KAAA,OAAAoB,UAAA,CAAAQ,cAAA,CAAAC,KAAA,EAAAC,OAAA;MACAA,OAAA,CAAAK,KAAA,CAAAN,KAAA,EAAA7B,KAAA;MACA,OAAAA,KAAA;IAAA;EAkFG;AAIH;AACJ,SAAAoC,cAAAC,OAAA;EAUO,OAASC,MAAA,CAAAC,MAAA,CACZ;IAEA,GAAAF,OAAO;IACHG,MAAG,EAAAA,CAAAxC,KAAA,EAAAC,MAAA,SAAAoC,OAAA,CAAAI,IAAA,CAAAzC,KAAA,EAAAC,MAAA;EAAA,EACH;AACI;AACA,SAAAyC,WAAcA,CAAAC,KAAA,EAAO;EACrB,OAAAL,MAAO,CAAAC,MAAA;IACX,GAAAI,KAAA;IACHH,MAAA,EAAAA,CAAAxC,KAAA,EAAAC,MAAA,SAAA0C,KAAA,CAAAF,IAAA,CAAAzC,KAAA,EAAAC,MAAA;IACLiC,MAAA,EAAAL,KAAA;MAUO,MAAS7B,KAAA,OACZoB,UACY,CAAAQ,cAAA,CAAAC,KAAA,EAAAc,KAAA;MACZA,KAAO,CAAAR,KAAO,CAAAN,KAAO,EAAA7B,KAAA;MACjB,OAAGA,KAAA;IACH;EACJ,CAAC;AACL;AAcO,SAAS4C,YACZD,KAAA,EAGiB;EACjB,OAAO,WAAO,IAAOA,KAAA,WAAAA,KAAA,CAAAZ,SAAA;AAAA;AACd,SACHc,iBAAgBA,CAAAF,KAAS;EAAiC,IAC1D,CAAAC,WAAQ,CAAAD,KAAS;IACb,UAAMxC,WAAY,CAAA2C,2CAAuC;EACzD;AACA;AAAO,SACXC,eAAAJ,KAAA;EACJ,OAAC,CAAAC,WAAA,CAAAD,KAAA;AACL;AAcO,SAASK,oBAAiGA,CAAAL,KAAA;EAC7G,KAAAI,cAAO,CAAAJ,KAAe;IAC1B,UAAAxC,WAAA,CAAA8C,8CAAA;EAcO;AAGH;AACI,SAAAC,YAAUA,CAAApB,OAAY,EAAAO,OAAA;EAC1B,IAAAO,WAAA,CAAAd,OAAA,MAAAc,WAAA,CAAAP,OAAA;IACJ,UAAAlC,WAAA,CAAAgD,iEAAA;EAQO;EACH,IAAAP,WAAQ,CAAAd,OAAY,KAAKc,WAAA,CAAAP,OAAA,KAAAP,OAAA,CAAAC,SAAA,KAAAM,OAAA,CAAAN,SAAA;IAC7B,UAAA5B,WAAA,CAAAiD,yDAAA;MAUOC,gBAAS,EAAAhB,OACZ,CAAAN,SACqC;MACjCuB,gBAAgB,EAAAxB,OAAQ,CAAAC;IACxB;EACJ;EACJ,KAAAa,WAAA,CAAAd,OAAA,MAAAc,WAAA,CAAAP,OAAA,KAAAP,OAAA,CAAAyB,OAAA,KAAAlB,OAAA,CAAAkB,OAAA;;;MC1NAC,cAAA,EAAA1B,OAAA,CAAAyB;IACI;EACA;EACA;IACA,GAAAlB,OAAA;IAAA,GACGP,OAAA;IAgCAU,MAAS,EAAAH,OAAA,CAAAG,MACZ;IAGAN,MAAI,EAAAJ,OAAY,CAAAI,MAAO;IACnBO,IAAA,EAAMJ,OAAI,CAAAI,IAAA;IACdN,KAAA,EAAAL,OAAA,CAAAK;EAEA;AACI;;AAC8B;AACA,SAC7BsB,WAAA3B,OAAA,EAAA4B,UAAA;EACL,OAAAzB,aAAA;IAEAF,SAAK,EAAA2B,UAAY;IACbvB,KAAA,EAAMA,CAAAN,KAAI,EAAA7B,KAAA,EAAAC,MAAY;MAClB,MAAA0D,iBAAgB,GAAQ7B,OAAA,CAAAI,MAAA,CAAAL,KAAA;MACxB,MAAA+B,cAAgB,GAAAD,iBAAQ,CAAAzD,MAAA,GAAAwD,UAAA,GAAAC,iBAAA,CAAAhC,KAAA,IAAA+B,UAAA,IAAAC,iBAAA;MAC3B3D,KAAA,CAAAsB,GAAA,CAAAsC,cAAA,EAAA3D,MAAA;MACL,OAAAA,MAAA,GAAAyD,UAAA;IAEA;EAAO,EACH;AAAG;AACA,SACHG,UAAQA,CAAQxB,OAAA,EAAAqB,UAAA;EAAA,OAChBtB,aAAgB;IAChBL,SAAM,EAAA2B,UAAQ;IACdjB,IAAA,EAAAA,CAAOzC,KAAA,EAAAC,MAAQ;MACnBI,qCAAA,aAAAqD,UAAA,EAAA1D,KAAA,EAAAC,MAAA;MACJ,IAAAA,MAAA,QAAAD,KAAA,CAAAE,MAAA,GAAAwD,UAAA;;;MC7CO,IAASd,WACZ,CAAAP,OACA;QAEArC,KAAO,GAAA0B,QAAc,CAAA1B,KAAA,EAAAqC,OAAA,CAAAN,SAAA;MACjB;MACA,MAAQ,CAAAF,KAAA,CAAc,GAAAQ,OAAmB,CAAAI,IAAA,CAAAzC,KAAmB;MAIxD,OAAM,CAAA6B,KAAA,EAAA5B,MAAA,GAAAyD,UAA4B;IAClC;EAEA;AACA;AAAgB,SACpBI,SAAAnB,KAAA,EAAAe,UAAA;EACJ,OAACR,YAAA,CAAAO,UAAA,CAAAd,KAAA,EAAAe,UAAA,GAAAG,UAAA,CAAAlB,KAAA,EAAAe,UAAA;AACL;;AAYI;AAAqB,SACjBK,UAAWA,CAAAjC,OAAA,EAAAkC,KAAA;EAAA,OACX/B,aAA0B;IACtB,IAAAc,cAAA,CAAAjB,OAAA;MAAA,GAAAA,OAAsC;MAAAE,gBAAY,EAAAH,KAAY,IAAOC,OAAM,CAAAE,gBAAA,CAAAgC,KAAA,CAAAnC,KAAA;IAAA,IAAAC,OAAA;IAE3EK,KAAA,EAAIA,CAAAN,KAAA,EAAS7B,KAAK,EAAAC,MAAM,KAAA6B,OAAS,CAAAK,KAAA,CAAY6B,KAAA,CAAAnC,KAAA,GAAA7B,KAAA,EAAAC,MAAA;EACzC;AAA+C;AAGnD,SAAAgE,UAAIA,CAAA5B,OAAY,EAAO6B,GAAG;EACtB,OAAA9B,aAAQ;IAAiC,GAC7CC,OAAA;IAEAI,IAAA,EAAAA,CAAAzC,KAAO,EAAKC,MAAI;MAChB,OAAO4B,KAAC,EAAAsC,SAAO,CAAS,GAAA9B,OAAU,CAAAI,IAAA,CAAAzC,KAAA,EAAAC,MAAA;MACtC,QAAAiE,GAAA,CAAArC,KAAA,EAAA7B,KAAA,EAAAC,MAAA,GAAAkE,SAAA;IACH;EACL;AAQO;AAIH,SAAOC,SAAAzB,KAAa,EAAAqB,KAAA,EAAAE,GAAW;EACnC,OAAAxB,WAAA;;;EClDO;AAIH;;AAGU;AAC8E,SACvF2B,cAAAvC,OAAA,EAAAwC,MAAA;EACL,OAAArC,aAAA;IAiBO,GAAAH,OAAS;IAIZK,KAAO,EAAAA,CAAAN,KAAA,EAAA7B,KAAc,EAAAuE,SAAA;MACjB,MAAGC,SAAA,GAAAvE,MAAA,IAAAwE,MAAA,CAAAxE,MAAA,EAAAD,KAAA,CAAAE,MAAA;MACH,MAAOwE,YAAmB,GAAAJ,MAAW,CAAAC,SAAA,GAAAD,MAAA,CAAAC,SAAA;QAAAvE,KAAA;QAAAuE,SAAA;QAAAC;MAAA,KAAAD,SAAA;MACjC9D,oCAAmC,gBAAY,EAAMiE,YAAA,EAAA1E,KAAA,CAAAE,MAAA;MACrD,MAAAyE,UAAY,GAAO7C,OAAO,CAAAK,KAAM,CAAAN,KAAG,EAAA7B,KAAS,EAAA0E,YAAA;MAChD,MAAAE,aAAA,GAAAN,MAAA,CAAAK,UAAA,GAAAL,MAAA,CAAAK,UAAA;QAAA3E,KAAA;QAAA0E,YAAA;QAAAC,UAAA;QAAAJ,SAAA;QAAAC;MAAA,KAAAG,UAAA;MACHlE,oCAAA,kBAAAmE,aAAA,EAAA5E,KAAA,CAAAE,MAAA;MACL,OAAA0E,aAAA;IAgCO;EAKH;AAAmB;AACW,SAC1BC,aAAYA,CAAAxC,OAAW,EAAAiC,MAAU,EAAE;EACvC,OAAClC,aAAA;IACL,GAAAC,OAAA;;;MC9EO,MAASqC,YAA6C,GAAAJ,MAAmB,CAAAC,SAAgC,GAAAD,MAAA,CAAAC,SAAA;QAAAvE,KAAA;QAAAuE,SAAA;QAAAC;MAAA,KAAAD,SAAA;MAC5G9D,oCAAqB,kBAAAiE,YAAA,EAAA1E,KAAA,CAAAE,MAAA;MACjB,MAAG,CAAA2B,KAAA,EAAA8C,UAAA,IAAAtC,OAAA,CAAAI,IAAA,CAAAzC,KAAA,EAAA0E,YAAA;MACH,MAAQE,aAAO,GAAON,MAAA,CAAAK,UAAc,GAAAL,MAAA,CAAAK,UAAA;QAAA3E,KAAA;QAAA0E,YAAA;QAAAC,UAAA;QAAAJ,SAAA;QAAAC;MAAA,KAAAG,UAAA;MAChClE,oCAAsC,CAAO,eAAc,EAAAmE,aAAM,EAAA5E,KAAA,CAAAE,MAAA;MACjE,OAAM,CAAA2B,KAAA,EAAA+C,aAAsB;IAC5B;EACA;AACA;AAGA,SAAAE,YAAAnC,KAAA,EAAA2B,MAAA;EACA,OAAApB,YAAO,CAAAmB,aAAA,CAAA1B,KAAA,EAAA2B,MAAA,GAAAO,aAAA,CAAAlC,KAAA,EAAA2B,MAAA;AAAA;AACX,SACHG,OAAAM,QAAA,EAAAC,OAAA;EACL,IAAAA,OAAA,QAMO,OAAS;EACZ,OAAO,CAAAD,QAAA,GAAAC,OAAc,GAAAA,OAAA,IAAAA,OAAA;AAAA;AACd,SACHC,aAAcA,CAAAnD,OAAA,EAAcoD,MAAA;EACxB,IAAAtC,WAAM,CAAAd,OAAa;IACnB,MAAAC,SAAM,GAAAmD,MAAe,CAAApD,OAAO,CAAAC,SAAY;IACxC,IAAAA,SAAA;MACA,MAAM,IAAC5B,WAAO,CAAAgF,mDAA8C;QAC5D5E,WAAM,EAAAwB,SAAgB;QAGtBhC,gBAAA;MACA;IACJ;IACH,OAAAkC,aAAA;MAAA,GAAAH,OAAA;MAAAC;IAAA;EACL;EAMO,OAASE,aAAuC;IACnD,GAAAH,OAAO;IACXE,gBAAA,EAAAH,KAAA;MAGA,MAASuD,OAAO,GAAAF,MAAkB,CAAApD,OAAiB,CAAAE,gBAAA,CAAAH,KAAA;MAC3C,IAAAuD,OAAA,GAAY;QAAG,MAAO,IAAAjF,WAAA,CAAAgF,mDAAA;UACjB5E,WAAW,EAAA6E,OAAA;UACxBrF,gBAAA;;;MClFA,OAASqF,OAAA;IA4BF;EAIH;AACI;AACA,SAAIC,aAAYA,CAAGhD,OAAA,EAAA6C,MAAA;EACf,IAAAtC,WAAU,CAAAP,OAAA;IAAiE,MACvEN,SAAA,GAAamD,MAAA,CAAA7C,OAAA,CAAAN,SAAA;IAAA,IACbA,SAAA;MACJ,MAAC,IAAA5B,WAAA,CAAAgF,mDAAA;QACL5E,WAAA,EAAAwB,SAAA;QACAhC,gBAAO,EAAc;MACzB;IACA;IACI,OAAGqC,aAAA;MAAA,GAAAC,OAAA;MAAAN;IAAA;EAAA;EAEC,OAAAM,OAAM;AACN;AACI,SAAAiD,WAAUA,CAAA3C,KAAA,EAAAuC,MAAY;EAAqD,OAAAhC,YACvE,CAAA+B,aAAa,CAAAtC,KAAA,EAAAuC,MAAA,GAAAG,aAAA,CAAA1C,KAAA,EAAAuC,MAAA;AAAA;;AAEhB;AAEL,SAAAK,cAAOA,CAAAzD,OAAA,EAAA7B,MAAA;EAAA,OACXoE,aAAA,CACHY,aAAA,CAAAnD,OAAA,EAAA0D,IAAA,IAAAA,IAAA,GAAAvF,MAAA,GACL;IAAAsE,SAAA,EAAAA,CAAA;MAAAA;IAAA,MAAAA,SAAA,GAAAtE;EAAA,CAiBO;AAIH;AACI,SAAAwF,eAAkBA,CAAA3D,OAAO,EAAA7B,MAAQ;EACjC,OAAIoE,aAAY,CACZY,aAAU,CAAAnD,OAAA,EAAA0D,IAAY,IAAAA,IAAA,GAAAvF,MAAA,GAAqD;IAAA0E,UACvE,EAAAA,CAAA;MAAaA;IAAA,MAAAA,UAAA,GAAA1E;EAAA;AACK;AACrB,SACLyF,eAAArD,OAAA,EAAApC,MAAA;EACA,OAAA4E,aAAO,CACXQ,aAAA,CAAAhD,OAAA,EAAAmD,IAAA,IAAAA,IAAA,GAAAvF,MAAA,GACA;IAAAsE,SAAO,EAAAA,CAAA;MAAAA;IAAA,MAAAA,SAAA,GAAAtE;EAAA,CACX;AAaO;AACH,SAAO0F,eAAaA,CAAAtD,OAAA,EAAApC,MAAc;EACtC,OAAA4E,aAAA,C;;;;GC7FO;AACH;AAAO,SACHe,YAAcA,CAAAjD,KAAS,EAAA1C,MAAA,EAAQ;EAAa,OAC1CiD,YAAc,CAAAqC,cAAgB,CAAA5C,KAAA,EAAA1C,MAAY,GAAAyF,cAAO,CAAA/C,KAAA,EAAA1C,MAAA;AAAA;AAE3D,SAAA4F,cAAAlD,KAAA,EAAA1C,MAAA;EAMO,OAASiD,YAAA,CAAAuC,eAAkE,CAAA9C,KAA0B,EAAA1C,MAAA,GAAA0F,eAAA,CAAAhD,KAAA,EAAA1C,MAAA;AACxG;;AACgD;AACU,SAC1D6F,eAAAhE,OAAA;EACJe,iBAAA,CAAAf,OAAA;EAMO,OAASG,aAAA;IACZ,GAAAH,OAAO;IACHK,KAAA,EAAAA,CAAAN,KAAA,EAAc7B,KAAA,EAAAC,MAAS,KAAQ;MAC7B,MAAAkE,SAAc,GAAArC,OAAU,CAAAK,KAAM,CAAAN,KAAA,EAAA7B,KAAY,EAAAC,MAAO;MACvD,MAAA0B,KAAA,GAAA3B,KAAA,CAAA2B,KAAA,CAAA1B,MAAA,EAAAA,MAAA,GAAA6B,OAAA,CAAAC,SAAA,EAAAgE,OAAA;MACJ/F,KAAA,CAAAsB,GAAA,CAAAK,KAAA,EAAA1B,MAAA;MAMO,OAASkE,SAAA;IACZ;EAAO,EACH;AAA4C;AACU,SAC1D6B,eAAA3D,OAAA;EACJQ,iBAAA,CAAAR,OAAA;EAMO,OAASD,aAAwC;IACpD,GAAAC,OAAO;IACXI,IAAA,EAAAA,CAAAzC,KAAA,EAAAC,MAAA;MAMO,MAASgG,UAAA,GAAyChG,MAAe,GAAAoC,OAAwB,CAAAN,SAAA;MAC5F,IAAO9B,MAAA,MAAa,IAAAD,KAAA,CAAAE,MAAgB,KAAA+F,UAAa,EAAG;QACxD,OAAA5D,OAAA,CAAAI,IAAA,CAAAzC,KAAA,CAAA+F,OAAA,IAAA9F,MAAA;;;MClDOiG,aAAS,CAAA5E,GAAA,CACZtB,KAAA,CAAA2B,KAC8B,CAAA1B,MAAA,EAAAgG,UAAA,EAAAF,OAAA,IAAA9F,MAAA;MAC9B,OAAAoC,OAAkB,CAAAI,IAAA,CAAAyD,aAAO,EAAAjG,MAAA;IACzB;EAAqB,EACjB;AAAG;AAEC,SAAAkG,YAAMA,CAAAxD,KAAY;EAClB,OAAAO,YAAc,CAAA4C,cAAY,CAAAnD,KAAQ,GAAAqD,cAAiB,CAAArD,KAAA,CAAS;AAC5D;AACO,SACXtC,qCAAA,EAAAP,iCAAA,EAAAW,oCAAA,EAAAoC,iBAAA,EAAAG,oBAAA,EAAAE,YAAA,EAAAR,WAAA,EAAAN,aAAA,EAAAH,aAAA,EAAAP,QAAA,EAAAoC,QAAA,EAAAD,UAAA,EAAAJ,UAAA,EAAA7B,cAAA,EAAAgB,WAAA,EAAAG,cAAA,EAAAqB,QAAA,EAAAH,UAAA,EAAAF,UAAA,EAAApD,UAAA,EAAAmE,WAAA,EAAAD,aAAA,EAAAR,aAAA,EAAA9C,QAAA,EAAAqE,YAAA,EAAAF,cAAA,EAAAH,cAAA,EAAAM,aAAA,EAAAF,eAAA,EAAAF,eAAA,EAAAH,WAAA,EAAAD,aAAA,EAAAJ,aAAA,EAAAkB,YAAA,EAAAH,cAAA,EAAAF,cAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}